---
title: 다양한 입출력장치의 특성
date: "2023-09-05T20:35:32.169Z"
template: "post"
draft: false
slug: "/posts/computer_architecture"
category: "Computer Architecture"
tags:
  - "Computer Architecture"
  - "CS"
description: "다양한 입출력장치의 특성에 대해서 배웁니다."
---

- [RAID의 정의와 종류](#raid의-정의와-종류)
  - [RAID의 정의](#raid의-정의)
  - [RAID](#raid)
- [장치 컨트롤러와 장치 드라이버](#장치-컨트롤러와-장치-드라이버)
  - [입출력장치 정보 주고받기](#입출력장치-정보-주고받기)
  - [장치 컨트롤러의 역할](#장치-컨트롤러의-역할)
  - [장치 컨트롤러의 구조](#장치-컨트롤러의-구조)
  - [장치 드라이버](#장치-드라이버)
- [다양한 입출력 방법](#다양한-입출력-방법)
  - [프로그램 입출력](#프로그램-입출력)
    - [메모리 맵 입출력](#메모리-맵-입출력)
    - [고립형 입출력](#고립형-입출력)
  - [인터럽트 기반 입출력](#인터럽트-기반-입출력)
  - [DMA 입출력](#dma-입출력)
    - [DMA](#dma)
    - [DMA 입출력 과정](#dma-입출력-과정)
  - [입출력 버스](#입출력-버스)

## raid의 정의와 종류

1TB 하드디스크 네 개로 RAID를 구성하면 4TB 하드 디스크 한 개의 성능과 안전성을 능가할 수 있다.

HDD, SSD같은 저장장치를 관리할 때 안전하고 성능을 높이는 방식은 RAID만 있는 것은 아니다. 다양하다

### raid의 정의

Redundant(복수) Array of Independent Disks

- 하드 디스크와 SSD로 사용하는 기술
- <Mark>데이터의 안전성 혹은 높은 성능</Mark>을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술
- 1TB + 1TB + 1TB + 1TB = 4TB, 마치 4TB를 하나의 논리적인 장치로 사용하는 것

RAID 레벨

- RAID를 구성하는 기술
- <Mark>RAID 0, RAID 1</Mark>, RAID 2, RAID 3, <Mark>RAID 4, RAID 5, RAID 6</Mark>
- 그로부터 파생된(nested) RAID 10, RADI 50, …

1. RAID 0
    - 데이터를 단순히 나누어 저장하는 구성 방식
    - 각 하드 디스크는 번갈아 가며 데이터를 저장
    - 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장
        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/90e44776-b2c1-4d97-a4a8-1193e6e66a3a)

        - 스트라입(stripe): 마치 줄무늬처럼 분산되어 저장된 데이터
        - 스트라이핑(striping): 분산하여 저장하는 것
    - 장점: 입출력 속도의 향상
            ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/8a14838c-16e0-4e83-882b-2501d9f4780f)
    - 단점: 저장된 정보가 안전하지 않음

        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/89f37c1c-596b-4737-ae53-445a3f9d93cb)
2. RAID 1
    - 미러링(mirroring): 복사본을 만드는 방식
    - 데이터를 쓸 떄 원본과 복사본 두 군데에 씀(느린 쓰기 속도)

        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/c456f444-4551-436e-8990-2a68a529c267) 
    - 장점: <Mark>백업과 복구</Mark>의 속도 향상, 안전하게 데이터를 저장할 수 있다
    - 단점:  하드 디스크 개수가 한정되었을 떄 사용 가능한 용량이 적어짐
        - 복사본이 만들어지는 용량만큼 사용 불가 → 많은 양의 하드 디스크가 필요 → 비용 증가
3. RAID 4
    - (RAID 1 처럼 완전한 복사본을 만드는 대신) <Mark>패리티 비트</Mark>를 저장
    - 패리티를 저장한 장치를 이용해 다른 장치들의 오류를 검출하고, 오류가 있다면 복구

        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/ded80437-ac70-425c-b397-b95411c749d4)
        c.f. ) 패리티 비트는 오류 검출만 가능할 뿐 오류 복구는 불가능, 하지만 RAID에서 사용되는 패리티  비트는 오류의 검출 뿐만이 아니라 오류 복구까지 가능
        - RAID 1 보다 적은 하드 디스크로도 데이터를 안전하게 보관
    - 단점: 패리티 디스크의 병목(많은 I/O 떄문)

        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/7f57c674-5530-4dd5-821b-cdf2295038e7)
4. RAID 5
    - 패리티 정보를 분산하여 저장하는 방식        

        ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/6e86ba99-ee88-4371-b17a-1946651053e4)

        - RAID 4는 패리티를 저장한 장치를 따로 두는 방식
        - RAID 5는 패리티를 분산하여 저장하는 방식
5. RAID 6
    - 두 종류의 패리티(오류를 검출하고 복구할 수 있는 수단)
        - RAID 5보다 안전, 쓰기는 RAID 5보다 느림        

            ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/a099229e-a69a-48c3-bf4c-01fce434b192)
### raid

- 각 RAID 레벨마다 장단점이 있음
    - 빠른 입출력 → RAID 0, 안전의 중요성 → RAID 1 or RAID 6
- 어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨은 달라질 수 있음
- 각 RAID 레벨의 대략적인 구성과 특징을 아는 것이 중요

    ![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/5edf0de5-ffb6-46b8-9216-bbf3574a1038)
    
    - 실제로 RAID 구성 가능

## 장치 컨트롤러와 장치 드라이버

보조기억장치도 입출력장치의 한 종류로 볼 수 있음 → 메모리를 보조하는 입출력장치

### 입출력장치 정보 주고받기

1. 장치가 다양하면 장치마다 속도, 데이터 전송 형식 등도 다양하다.

→ 다양한 입출력장치와 정보를 주고받는 방식을 <Mark>규격화</Mark>하기 어렵다

1. 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 <Mark>전송률</Mark>은 낮다.
    - 전송률: 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표

이런 이유로 입출력장치는 <Mark>장치 컨트롤러</Mark>를 통해 컴퓨터와 정보를 주고받으며 연결된다

- 입출력 제어기(I/O controller), 입출력 모듈(I/O module)

### 장치 컨트롤러의 역할

- CPU와 입출력장치의 통신 중개
    - 규격화의 어려움을 해결하는 일종의 번역기 역할 수행
- 오류검출
- 데이터 버퍼링
    - 버퍼링
        - 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 <Mark>버퍼</Mark>라는 임시저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법

### 장치 컨트롤러의 구조

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/76e35b8a-d528-4dad-a453-4f136b107876)

- 장치 컨트롤러는 입/출력 버스에 연결된다.
- 주고받는 정보는 데이터, 상태, 제어로 나뉜다.

c.f. ) 상태 레지스터와 제어 레지스터는 하나의 레지스터(상태/제어 레지스터)로 사용되기도 

데이터 레지스터

- CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터(버퍼의 역할)
- RAM을 사용하기도

상태 레지스터

- 상태 정보 저장
    - 입출력장치가 입출력 작업을 할 준비가 되었는지,
    - 입출력 작업이 완료되었는지
    - 입출력장치에 오류는 없는지 등의 상태 정보

제어 레지스터

- 입출력장치가 수행할 내용에 대한 제어 정보

### 장치 드라이버

**장치 컨트롤러의 동작을 감지하고 제어하는 프로그램**

장치 드라이버를 인식하고 실행시키는 주체는 운영체제

장치 컨트롤러가 입출력장치를 연결하기 위한 <Mark>하드웨어적 통로</Mark>라면, 장치 드라이버는 입출력장치를 연결하기 위한 <Mark>소프트웨어적 통로

→ 장치 드라이버가 설치되어 있지 않다면 해당 입출력장치를 사용할 수 없다 

컴퓨터가(<Mark>운영체제</Mark>) 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 컴퓨터 내부와 정보를 주고받을 수 있음

반대로 컴퓨터(운영체제)가 장치 드라이버를 인식하거나 실행할 수 없다면 그 장치는 컴퓨터 내부와 정보를 주고받을 수없음 

<Mark>→ CPU는 연결된 장치 컨트롤러를 어떻게 제어하고 동작시키는지 모르기 떄문


## 다양한 입출력 방법

세 가지 입출력 방식: 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력에 대해서 알아보자

### 프로그램 입출력

프로그램 속 명령어로 입출력장치를 제어하는 방법

입출력 명령어로써 장치 컨트롤러와 상호작용

메모리에 저장된 정보를 하드 디스크에 <Mark>백업</Mark>(=하드 디스크에 새로운 정보 <Mark>쓰기</Mark>)

1. CPU는 하드 디스크 컨트롤러의<Mark>제어 레지스터</Mark>에 <Mark>쓰기</Mark> 명령 내보내기

2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 → 상태 레지스터에 <Mark>준비 완료</Mark> 표시

3. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인

4. 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓰기

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/6264cddc-a243-4f5c-a3ee-8c9e543c5e75)

아직 백업 작업(쓰기 작업)이 끝나지 않았다면 1번부터 반복, 쓰기가 끝났다면 작업 종료

하드 디스크 컨트롤러의 특정 레지스터에 입출력 명령어로서 입출력 작업을 수행하는 것이 프로그램 입출력 방식

- <Mark>CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀</Mark>으로서 이루어진다

프로그램 입출력 방식

CPU가 장치 컨트롤러의 레지스터 값들을 알기 위한 방법으로 <Mark>메모리 맵 입출력 & 고립형 입출력이 있다.

#### 메모리 맵 입출력

- <Mark>메모리</Mark>에 접근하기 위한 주소공간과 <Mark>입출력장치</Mark>에 접근하기 위한 주소 공간을 <Mark>하나의 주소 공간</Mark>으로 간주하는 방법
- 별도의 입출력 명령어가 필요하지 않은 방식, 메모리를 읽고 쓰는것과 동일하게 장치컨트롤러의 레지스터에 값을 읽고 쓸수 있음


![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/b117970c-5594-407a-b5c0-14ea749d3ff7)
   
   - 516번지: 프린터 컨트롤러의 데이터 레지스터
- 517번지: 프린터 컨트롤러의 상태 레지스터
    - <Mark>‘517 번지를 읽어 들여라’ == 프린터 상태 읽기
- 518번지: 하드 디스크 컨트롤러의 데이터 레지스터
    - <Mark>‘518 번지에 a를 써라’ == 하드 디스크에 a 쓰기
- 519번지: 하드 디스크 컨트롤러의 상태 레지스터

<Mark>메모리 접근 명령어 == 입출력장치 접근 명령어가 동일한 입출력 방식

#### 고립형 입출력

<Mark>메모리를 위한 주소 공간</Mark>과 <Mark>입출력 장치를 위한 주소 공간</Mark>을 <Mark>분리</Mark>하는 방법

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/667df59b-b7f9-42fb-973d-bc72348c7832)

(입출력 읽기/쓰기 선을 활성화시키는) 입출력 전용 명령어 사용, 메모리 전용 명령어도 존재

제어 버스에서 각기(<Mark>메모리, 입출력장치</Mark>) 전용 명령어를 통해 읽기/쓰기 선이 활성화


![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/6f889f7e-efa1-4bca-a3ad-14d00e3c5861)


![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/8dc172ee-da9f-42fa-a1d5-f0f5635c2651)

### 인터럽트 기반 입출력

- (하드웨어) 인터럽트의 개념
    - CPU 사이클의 낭비를 막기 위해서 입출력장치가 일을 할 동안 다른 일을 할 수 있도록 일종의 알람 같은 개념
- 플래그 레지스터 속 인터럽트 비트
    - 인터럽트 비트가 활성화되면 (하드웨어)인터럽트를 받아들일 수 있게되고 비활성화되면 받을 수 없게 됨
- 인터럽트 요청 신호
    - 입출력장치가 CPU에게 요청을 신호로서 보내는 것
- 인터럽트 서비스 루틴
    - CPU가 인터럽트 요청 신호를 받으면 인터럽트를 처리하기 위한 특별한 프로그램

하드웨어 인터럽트는 장치 컨트롤러에 의해 발생 → CPU 사이클을 효율적으로 관리 가능

- 메모리에 저장된 정보를 하드 디스크에 백업할 때 CPU가 상태 레지스터를 주기적으로 읽지만(인터럽트와 반대되는 <Mark>폴링</Mark>이라고도 함), 인터럽트는 요청 신호를 발생

동시다발적인 인터럽트: 많은 입출력장치의 장치 컨트롤러들이 CPU에게 인터럽트 요청 신호를 보내는 상황을 생각해보자

인터럽트 발생 순서대로 처리 가능

- 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우
    - NMI - 순차적으로 처리가 불가능한 인터럽트가 있음(정전, 고장) critical한 인터럽트가 발생하는 경우

현실적으로 모든 인터럽트를 순차적으로 처리할 수 는 없다, 인터럽트 중에서도 <Mark>더 빨리 처리해야하는(우선순위가 높은) 인터럽트</Mark>가 있다.

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/da66f3b4-da51-494c-95c4-824fc752299e)

→ NMI가 발생한 경우, 플래그 레지스터 속 인터럽트 비트를 활성화한 채 인터럽트를 처리하는 경우


동시다발적인 인터럽트 - 우선순위를 반영한 인터럽트

PIC(Programmable Interrupt Controller)

장치 컨트롤러와 CPU사이에서 어떤 인터럽트를 가장 우선으로 처리해야 하는지를 판단해서 CPU가 처리해야 하는 인터럽트를 알려줌(<Mark>다중 인터럽트 가능</Mark>)

1. 여러 장치 컨트롤러에 연결되어
2. 장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤
3. CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어

c.f. ) NMI 우선순위까지 판단하지는 않음

###  dma 입출력

프로그램 입출력, 인터럽트 기반 입출력의 공통점

- 입력장치와 메모리 간의 데이터 이동은 <Mark>CPU가 주도하고
- 이동하는 데이터도 반드시 <Mark>CPU를 거친다

→ 하드디스크의 데이터를 메모리에 저장하는 경우, 하드디스크의 <Mark>데이터 레지스터에 저장되어 있는 값</Mark>을 입출력장치를 읽어들임으로서 <Mark>CPU레지스터로 읽어들이게 되고</Mark> 레지스터로 읽어들인 값을 메모리로 쓰게 된다.

하드 디스크 백업과 같이 대용량 데이터를 이동한다면 CPU의 효율이 떨어짐 → DMA 등장

#### dma

Direct Memory Access

CPU를 거치지 않고 입출력장치와 메모리간의 데이터를 <Mark>직접적으로 주고받는</Mark> 입출력 방식

#### dma 입출력 과정

1. CPU는 DMA 컨트롤러에 입출력 작업을 명령
2. DMA 컨트롤러는 CPU대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
    - 이 떄 HDD에 메모리 정보를 백업하는 입출력작업이라면 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근
    - DMA 컨트롤러가 메모리와 장치컨트롤러가 상호작용하면서 입출력하는 도중 CPU는 다른 작업이 가능
    - 메모리와 장치컨트롤러 사이의 주고받는 데이터는 CPU를 거치지 ❌
3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림

 

결과적으로 CPU는 입출력 작업의 <Mark>시작과 끝</Mark>만 관여

앞선 예시의 DMA 과정에서 시스템 버스를 이용

그런데, 시스템 버스는 공용 자원이기에 동시 사용이 불가능

CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 없고, DMA컨트롤러는 시스템 버스를 사용할 떄는 CPU가 시스템 버스를 사용할 수 없음

그래서 DMA 컨트롤러는 

1. CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/84e516ac-a1dc-48ee-bdcb-8fb351b7d471)

→ DMA 컨트롤러가 시스템 버스를 이런식으로 이용하는 양상을 Cycle Stealing이라고도 함

### 입출력 버스

DMA 컨트롤러가 시스템 버스를 (불필요하게)이용하는 것을 방지하기 위해 등장

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/d87c3126-394b-4894-9997-cb50ba708a60)

e.g. PCI 버스, PCI express (PCIe) 버스와 입출력 장치를 연결짓는 슬롯

슬롯 → 입출력 버스 → 시스템 버스

![image](https://github.com/adamschwartz/magic-of-css/assets/74396128/50b5411e-9d17-4757-9de1-4fd77493e52a)

더욱 발전한 DMA, 입출력 프로세서(입출력 채널) → 입출력장치가 입출력 전용 CPU, RAM을 탑재한 경우도 있다.