---
title: 프로세스와 스레드
date: "2023-09-12T20:35:32.169Z"
template: "post"
draft: false
slug: "/posts/os"
category: "OS"
tags:
  - "OS"
  - "CS"  
description: "프로세스와 스레드에 대해서 배웁니다"
---

- [프로세스 상태와 계층구조](#프로세스-상태와-계층구조)
    - [프로세스 상태](#프로세스-상태)
    - [프로세스 계층 구조](#프로세스-계층-구조)
    - [프로세스 생성 기법](#프로세스-생성-기법)
    - [ROM-BIOS](#rom-bios)
- [스레드](#스레드)
    - [프로세스와 스레드](#프로세스와-스레드)
    - [멀티 프로세스와 멀티 스레드](#멀티-프로세스와-멀티-스레드)
- [프로세스 확인하기](#프로세스-확인하기)
- [스레드 확인하기](#스레드-확인하기)
- [CPU 스케줄링 개요](#cpu-스케줄링-개요)
    - [프로세스 우선순위](#프로세스-우선순위)
    - [스케줄링 큐](#스케줄링-큐)
- [선점형(Preemptive)과 비선점형 스케줄링(Non-preemptive)](#선점형과-비선점형-스케줄링)

## 프로세스 상태와 계층구조

### 프로세스 상태

- 생성상태
    - 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
    - 준비가 완료되었다면 준비 상태로
- 준비상태
    - 당장이라도 CPU를 할당 받아 실행할 수 있지만
    - 자신의 차례가 아니기에 기다리는 상태
    - 자신의 차례가 된다면 실행 상태로(=<Mark>디스패치</Mark>(준비→실행))
- 실행상태
    - CPU를 할당 받아 실행 중인 상태
    - 할당된 시간 모두 사용 시(<Mark>타이머 인터럽트</Mark>(할당된 시간을 전부 사용했음을 나타내는 하드웨어 인터럽트) 발생 시) 준비 상태로
    - 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지(<Mark>입출력 완료 인터럽트를 받을 때까지</Mark>) 대기 상태로
- 대기상태(block state)
    - 프로세스가 실행 도중 입출력장치를 사용하는 경우
    - 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
    - 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로
- 종료상태
    - 프로세스가 종료된 상태
    - PCB, 프로세스의 메모리 영역 정리
        ![image](https://github.com/boost-library/yong-study/assets/74396128/eccf0a31-0da9-4dbb-83c2-c9b5983bc9e0)

### 프로세스 계층 구조

- 프로세스 실행 도중(<Mark>시스템 호출을 통해</Mark>) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스: 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스: 자식 프로세스
    - 부모 프로세스와 자식 프로세스는 <Mark>별개의 프로세스</Mark>이므로 <Mark>각기 다른 PID</Mark>를 가짐
    - 일부 운영체제에서는 자식 프로세스 <Mark>PCB에 부모 프로세스 PID(PPID)를 명시하기도
    
    → 프로세스의 게층적인 구조 형성
    
- OS에서 데몬 프로세스는 백그라운드에서 실행되는 시스템 서비스나 작업을 수행하는 프로세스를 의미, 데몬 프로세스는 주로 리눅스와 유닉스 기반 운영 체제에서 많이 사용되며, Windows 운영 체제에서는 "서비스"
    - 데몬 프로세스는 처음으로 시작되는 프로세스의 자식 프로세스
        
        ```c
        최초의 프로세스 확인
        pstree
        ```
        
- c.f.) Windows는 계층 구조 ❌

### 프로세스 생성 기법

부모 프로세스는 <Mark>fork 시스템 호출</Mark>을 통해 자신의 복사본을 자식 프로세스로 생성

- 복사본(=자식 프로세스) 생성
- 부모 프로세스의 자원 상속

자식 프로세스는 <Mark>exec 시스템 호출</Mark>을 통해 <Mark>자신의 메모리 공간을 다른 프로그램으로 교체

- 메모리 공간을 새로운 프로그램으로 덮어쓰기
- 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화
    - <Mark>이때 부모 프로세스가 갖고있는 프로그램 내용은 자식 프로세스와 다르다.(별개)

### rom bios

ROM-BIOS(Read-Only Memory - Basic Input/Output System)은 운영 체제나 프로세스와 직접적으로 관련된 프로세스가 아니다. ROM-BIOS는 컴퓨터의 부팅 및 기본 입출력 시스템을 관리하는 하드웨어와 소프트웨어의 조합

ROM-BIOS는 컴퓨터의 기본 입력 및 출력 작업을 처리하며, 부팅 시 초기 하드웨어 설정 및 컴퓨터의 기본 동작을 관리. 이는 운영 체제의 부팅 전 단계에서 실행되며, 컴퓨터의 기본 하드웨어를 초기화하고 저장 장치에서 운영 체제를 로드. 이후 운영 체제가 로드되면 운영 체제가 컴퓨터 시스템을 제어하고 프로세스를 관리한다.

따라서 ROM-BIOS는 운영 체제나 프로세스와는 <Mark>구분되는 역할</Mark>을 한다. ROM-BIOS는 컴퓨터의 하드웨어와 초기 부팅 프로세스를 다루는데 사용되며, 운영 체제와 어플리케이션은 이후에 실행되는 소프트웨어.

## 스레드

스레드(thread)는 프로세스를 구성하는 실행 흐름의 단위

하나의 프로세스는 하나 이상의 스레드를 가질 수 있다
    ![image](https://github.com/boost-library/yong-study/assets/74396128/3c4fb422-9e0c-496e-972e-2e78e2e8897b)
    한 프로세스를 여러개의 스레드로 동시에 실행

### 프로세스와 스레드

실행 흐름이 하나인 프로세스(단일 스레드 프로세스)

실행 흐름이 여러 개인 프로세스(멀티 스레드 프로세스)

- 프로세스를 이루는 여러 명령어 동시 실행 가능

**스레드의 구성 요소**

스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등

<Mark>실행에 필요한 최소한의 정보
    ![image](https://github.com/boost-library/yong-study/assets/74396128/d3363057-79d0-4a5d-a4a3-dcc086240e2f)
    🔥<Mark>프로세스를 이루는 모든 스레드들은 그 프로세스의 자원을 공유할 수 있다

- <Mark>리눅스</Mark> 운영체제에서의 스레드
    - <Mark>프로세스와 스레드는 “실행의 문맥(context of execution)”, 별개의 것으로 구분할 필요 ❌ - 리눅스 토발즈
    - <Mark>task</Mark>라는 용어로 대체하여 사용
    - 다른 운영체제에서는 아직까지 구분한다.
- c.f. ) 전통적인 관점의 전공서에서는 CPU한테 처리해야할 작업을 처리할 때 <Mark>프로세스 단위</Mark>로 전달한다고 나와있지만, 실제로 확인해보면 CPU한테 처리해야 할 작업을 전달하거나 CPU를 할당받아 실행되는 단위는 프로세스가 아니라 <Mark>스레드 단위</Mark>인 경우가 많다

### 멀티 프로세스와 멀티 스레드

동일한 작업을 수행하는 <Mark>단일 스레드 프로세스 여러 개</Mark> 실행 vs 하나의 프로세스를 <Mark>여러 스레드</Mark>로 실행
    ![image](https://github.com/boost-library/yong-study/assets/74396128/6d5006ba-9a51-4c5c-9017-6607c1a8498e)
    → 프로세스끼리는 기본적으로 자원을 공유하지 않지만 스레드끼리는 같은 프로세스의 자원을 공유하는 차이점이 있다

- process
    - 프로세스를 fork하면 코드/데이터/힙 영역 등 모든 자원이 복제되어 저장됨
    - 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재
        - c.f. ) 실제로는 fork 직후 같은 프로세스를 <Mark>통째로 메모리에 중복 저장하지 않으면서</Mark> 동시에 프로세스끼리 자원을 공유하지 않는 방법이 있다. 이를 <Mark>쓰기 시 복사(copy on write)기법</Mark>이라 한다.
- thread
    - 스레드들은 각기 다른 스레드 ID, (별도의 실행을 위해 꼭 필요한) 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유
        ![image](https://github.com/boost-library/yong-study/assets/74396128/52f79880-1bda-4bac-abd2-e0e0c012361d)
- 프로세스끼리는 자원을 공유하지 않는다 → 남남처럼 독립적으로 실행
    - 프로세스 간에도 자원을 주고받을 수 있다 → 프로세스 간 통신(IPC)
    - 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신
    - c.f.) socket, pipe …
- 스레드는 프로세스의 자원을 공유 → 비교적 멀티프로세스에 비해 협력과 통신에 유리
    - 스레드 하나에 문제가 생기면 전체 프로세스에 문제가 생길 수 있음    

## 프로세스 확인하기

```c
vi test.py
print("hello, os")
python3 test.py

// PID 확인
vi test.py

import os
os.getpid() // PID 22662

// -----------------------------------
from multiprocessing import Process
import os

def foo():
    print('foo: child process: ', os.getpid()) // 자식 PID
    print('foo: paraent process: ', os.getppid()) // 자식의 부모 PID(22784)

if __name__ == '__main__':
    print('paraent process: ', os.getpid()) // paraent process:  22784
    child = Process(target=foo).start() // 자식 프로세스 생성
// ------------------------------------

// 멀티 process 생성
from multiprocessing import Process
import os

def foo():
    print('foo: child process: ', os.getpid())
    print('foo: paraent process: ', os.getppid())

if __name__ == '__main__':
    print('paraent process: ', os.getpid())
    child1 = Process(target=foo).start()
    child2 = Process(target=foo).start()
    child3 = Process(target=foo).start()
```

## 스레드 확인하기

```c
vi test.py
----------
import threading
import os

def foo():
    print('foo: thread id is: ', threading.get_native_id())
    print('foo: my pid is: ', os.getpid()) 
		// 23222, thread는 process의 자원 공유

if __name__ == '__main__':
    print('PID: ', os.getpid()) // 23222
    thread1 = threading.Thread(target=foo).start()
----------

```

## cpu 스케줄링 개요

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

### 프로세스 우선순위

<Mark>입출력 작업</Mark>이 많은 프로세스(=<Mark>I/O Bound Process</Mark>, 입출력 집중 프로세스)의 우선순위는

<Mark>CPU 작업</Mark>이 많은 프로세스(=<Mark>CPU Bound Process</Mark>, CPU 집중 프로세스)의 우선순위 보다 높다

- I/O Bound Process는 대기 상태에서 더 많이 존재하기에 입출력 작업이 우선순위가 높아서 프로세스 먼저 실행

### 스케줄링 큐

- 반드시 FIFO일 필요는 ❌

특정 자원(cpu,hdd, i/o devcie)을 이용하고 싶어하는 프로세스들을 큐에 삽입해서 자원을 이용하도록 만듦

- 준비 큐와 대기 큐
    - 준비 큐: CPU를 이용하기 위해 기다리는 줄
    - 대기 큐: 입출력장치를 이용하기 위해 기다리는 줄
        - 같은 장치를 요구한 프로세스들은 같은 큐에서 대기
            ![image](https://github.com/boost-library/yong-study/assets/74396128/dca033ec-bdaf-4241-a16c-d5189c97c5a9)
        - 먼저 큐에 삽입되더라도 반드시 먼저 실행되는 것은 아님, 우선순위가 높은 프로세스가 CPU를 이용 

## 선점형과 비선점형 스케줄링

**선점형 스케줄링(Preemptive)**

- 현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
- 어떤 프로세스 하나가 CPU 자원 하나를 독점해서 쓸 수 없는 스케줄링 방식
- 프로세스마다 정해진 시간만큼 CPU를 쓰게 하고 정해진 시간을 모두써서 타임아웃 인터럽트가 발생하면 OS가 다음 프로세스에게 CPU자원을 넘겨줌
- 장점
    - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능
- 단점
    - 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

**비선점형 스케줄링((Non-preemptive))**

- 현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
- 어느 한 프로세스가 자원을 이용하고 있다면 종료되거나 대기상태에 접어들기 전까지 다른 끼어들 수 ❌
- 장점
    - 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점
    - 모든 프로세스가 골고루 자원을 이용하기 어렵다

c.f. ) 문맥교환
    다중 프로그래밍 및 다중 작업 환경에서 발생하는 프로세스 간의 전환 작업을 의미

문맥 교환은 현재 실행 중인 프로세스의 상태(문맥)를 저장하고, 다음으로 실행될 프로세스의 상태를 복원하는 과정을 포함. 이를 통해 여러 프로세스가 CPU를 공유하며 실행될 수 있습니다.

문맥 교환은 다음과 같은 상황에서 발생할 수 있음:

1. 인터럽트: 하드웨어 인터럽트(예: 타이머 인터럽트, 입출력 완료 인터럽트) 또는 소프트웨어 인터럽트(예: 시스템 호출)에 의해 발생.
2. 스케줄러 결정: <Mark>스케줄러는 실행 중인 프로세스 중 하나를 중단하고 다른 프로세스를 실행하도록 결정할 때 발생</Mark>합니다. 이를 통해 다양한 프로세스 간에 CPU 시간을 공정하게 분배할 수 있음.
3. 입출력 작업: 입출력 작업을 수행하는 동안 CPU가 대기 상태에 들어가는 경우, 다른 프로세스로 전환하여 시스템 자원을 최대한 활용합니다.

문맥 교환은 오버헤드를 발생시킬 수 있으므로, 효율적으로 수행하기 위해 하드웨어와 운영 체제가 최적화되어야 한다. 문맥 교환은 다중 프로그래밍 환경에서 여러 작업이 동시에 실행될 수 있도록 해주는 핵심적인 운영 체제 기능 중 하나
