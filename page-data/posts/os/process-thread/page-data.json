{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/os/process-thread","result":{"data":{"markdownRemark":{"id":"bb39bdb1-ff97-589f-adf8-4d831133ce90","html":"<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C%EC%99%80-%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0\">프로세스 상태와 계층구조</a>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C\">프로세스 상태</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\">프로세스 계층 구조</a></li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1-%EA%B8%B0%EB%B2%95\">프로세스 생성 기법</a></li>\n<li><a href=\"#rom-bios\">ROM-BIOS</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C\">스레드</a>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C\">프로세스와 스레드</a></li>\n<li><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\">멀티 프로세스와 멀티 스레드</a></li>\n</ul>\n</li>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\">프로세스 확인하기</a></li>\n<li><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\">스레드 확인하기</a></li>\n<li><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EA%B0%9C%EC%9A%94\">CPU 스케줄링 개요</a>\n<ul>\n<li><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">프로세스 우선순위</a></li>\n<li><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%81%90\">스케줄링 큐</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\">선점형(Preemptive)과 비선점형 스케줄링(Non-preemptive)</a></li>\n<li><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\">CPU 스케줄링 알고리즘</a></li>\n</ul>\n<h2 id=\"프로세스-상태와-계층구조\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C%EC%99%80-%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0\" aria-label=\"프로세스 상태와 계층구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 상태와 계층구조</h2>\n<h3 id=\"프로세스-상태\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C\" aria-label=\"프로세스 상태 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 상태</h3>\n<ul>\n<li>생성상태\n<ul>\n<li>이제 막 메모리에 적재되어 PCB를 할당 받은 상태</li>\n<li>준비가 완료되었다면 준비 상태로</li>\n</ul>\n</li>\n<li>준비상태\n<ul>\n<li>당장이라도 CPU를 할당 받아 실행할 수 있지만</li>\n<li>자신의 차례가 아니기에 기다리는 상태</li>\n<li>자신의 차례가 된다면 실행 상태로(=<Mark>디스패치</Mark>(준비→실행))</li>\n</ul>\n</li>\n<li>실행상태\n<ul>\n<li>CPU를 할당 받아 실행 중인 상태</li>\n<li>할당된 시간 모두 사용 시(<Mark>타이머 인터럽트</Mark>(할당된 시간을 전부 사용했음을 나타내는 하드웨어 인터럽트) 발생 시) 준비 상태로</li>\n<li>실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지(<Mark>입출력 완료 인터럽트를 받을 때까지</Mark>) 대기 상태로</li>\n</ul>\n</li>\n<li>대기상태(block state)\n<ul>\n<li>프로세스가 실행 도중 입출력장치를 사용하는 경우</li>\n<li>입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬</li>\n<li>입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로</li>\n</ul>\n</li>\n<li>종료상태\n<ul>\n<li>프로세스가 종료된 상태</li>\n<li>PCB, 프로세스의 메모리 영역 정리\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/eccf0a31-0da9-4dbb-83c2-c9b5983bc9e0\" alt=\"image\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"프로세스-계층-구조\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0\" aria-label=\"프로세스 계층 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 계층 구조</h3>\n<ul>\n<li>\n<p>프로세스 실행 도중(<Mark>시스템 호출을 통해</Mark>) 다른 프로세스 생성 가능</p>\n</li>\n<li>\n<p>새 프로세스를 생성한 프로세스: 부모 프로세스</p>\n</li>\n<li>\n<p>부모 프로세스에 의해 생성된 프로세스: 자식 프로세스</p>\n<ul>\n<li>부모 프로세스와 자식 프로세스는 <Mark>별개의 프로세스</Mark>이므로 <Mark>각기 다른 PID</Mark>를 가짐</li>\n<li>일부 운영체제에서는 자식 프로세스 <Mark>PCB에 부모 프로세스 PID(PPID)를 명시하기도</li>\n</ul>\n<p>→ 프로세스의 게층적인 구조 형성</p>\n</li>\n<li>\n<p>OS에서 데몬 프로세스는 백그라운드에서 실행되는 시스템 서비스나 작업을 수행하는 프로세스를 의미, 데몬 프로세스는 주로 리눅스와 유닉스 기반 운영 체제에서 많이 사용되며, Windows 운영 체제에서는 “서비스”</p>\n<ul>\n<li>\n<p>데몬 프로세스는 처음으로 시작되는 프로세스의 자식 프로세스</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">최초의 프로세스 확인\r\npstree</code></pre></div>\n</li>\n</ul>\n</li>\n<li>\n<p>c.f.) Windows는 계층 구조 ❌</p>\n</li>\n</ul>\n<h3 id=\"프로세스-생성-기법\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1-%EA%B8%B0%EB%B2%95\" aria-label=\"프로세스 생성 기법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 생성 기법</h3>\n<p>부모 프로세스는 <Mark>fork 시스템 호출</Mark>을 통해 자신의 복사본을 자식 프로세스로 생성</p>\n<ul>\n<li>복사본(=자식 프로세스) 생성</li>\n<li>부모 프로세스의 자원 상속</li>\n</ul>\n<p>자식 프로세스는 <Mark>exec 시스템 호출</Mark>을 통해 <Mark>자신의 메모리 공간을 다른 프로그램으로 교체</p>\n<ul>\n<li>메모리 공간을 새로운 프로그램으로 덮어쓰기</li>\n<li>코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화\n<ul>\n<li><Mark>이때 부모 프로세스가 갖고있는 프로그램 내용은 자식 프로세스와 다르다.(별개)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"rom-bios\" style=\"position:relative;\"><a href=\"#rom-bios\" aria-label=\"rom bios permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>rom bios</h3>\n<p>ROM-BIOS(Read-Only Memory - Basic Input/Output System)은 운영 체제나 프로세스와 직접적으로 관련된 프로세스가 아니다. ROM-BIOS는 컴퓨터의 부팅 및 기본 입출력 시스템을 관리하는 하드웨어와 소프트웨어의 조합</p>\n<p>ROM-BIOS는 컴퓨터의 기본 입력 및 출력 작업을 처리하며, 부팅 시 초기 하드웨어 설정 및 컴퓨터의 기본 동작을 관리. 이는 운영 체제의 부팅 전 단계에서 실행되며, 컴퓨터의 기본 하드웨어를 초기화하고 저장 장치에서 운영 체제를 로드. 이후 운영 체제가 로드되면 운영 체제가 컴퓨터 시스템을 제어하고 프로세스를 관리한다.</p>\n<p>따라서 ROM-BIOS는 운영 체제나 프로세스와는 <Mark>구분되는 역할</Mark>을 한다. ROM-BIOS는 컴퓨터의 하드웨어와 초기 부팅 프로세스를 다루는데 사용되며, 운영 체제와 어플리케이션은 이후에 실행되는 소프트웨어.</p>\n<h2 id=\"스레드\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드</h2>\n<p>스레드(thread)는 프로세스를 구성하는 실행 흐름의 단위</p>\n<p>하나의 프로세스는 하나 이상의 스레드를 가질 수 있다\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/3c4fb422-9e0c-496e-972e-2e78e2e8897b\" alt=\"image\">\r\n한 프로세스를 여러개의 스레드로 동시에 실행</p>\n<h3 id=\"프로세스와-스레드\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"프로세스와 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스와 스레드</h3>\n<p>실행 흐름이 하나인 프로세스(단일 스레드 프로세스)</p>\n<p>실행 흐름이 여러 개인 프로세스(멀티 스레드 프로세스)</p>\n<ul>\n<li>프로세스를 이루는 여러 명령어 동시 실행 가능</li>\n</ul>\n<p><strong>스레드의 구성 요소</strong></p>\n<p>스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등</p>\n<p><Mark>실행에 필요한 최소한의 정보\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/d3363057-79d0-4a5d-a4a3-dcc086240e2f\" alt=\"image\">\r\n🔥<Mark>프로세스를 이루는 모든 스레드들은 그 프로세스의 자원을 공유할 수 있다</p>\n<ul>\n<li><Mark>리눅스</Mark> 운영체제에서의 스레드\n<ul>\n<li><Mark>프로세스와 스레드는 “실행의 문맥(context of execution)”, 별개의 것으로 구분할 필요 ❌ - 리눅스 토발즈</li>\n<li><Mark>task</Mark>라는 용어로 대체하여 사용</li>\n<li>다른 운영체제에서는 아직까지 구분한다.</li>\n</ul>\n</li>\n<li>c.f. ) 전통적인 관점의 전공서에서는 CPU한테 처리해야할 작업을 처리할 때 <Mark>프로세스 단위</Mark>로 전달한다고 나와있지만, 실제로 확인해보면 CPU한테 처리해야 할 작업을 전달하거나 CPU를 할당받아 실행되는 단위는 프로세스가 아니라 <Mark>스레드 단위</Mark>인 경우가 많다</li>\n</ul>\n<h3 id=\"멀티-프로세스와-멀티-스레드\" style=\"position:relative;\"><a href=\"#%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C\" aria-label=\"멀티 프로세스와 멀티 스레드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>멀티 프로세스와 멀티 스레드</h3>\n<p>동일한 작업을 수행하는 <Mark>단일 스레드 프로세스 여러 개</Mark> 실행 vs 하나의 프로세스를 <Mark>여러 스레드</Mark>로 실행\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/6d5006ba-9a51-4c5c-9017-6607c1a8498e\" alt=\"image\">\r\n→ 프로세스끼리는 기본적으로 자원을 공유하지 않지만 스레드끼리는 같은 프로세스의 자원을 공유하는 차이점이 있다</p>\n<ul>\n<li>process\n<ul>\n<li>프로세스를 fork하면 코드/데이터/힙 영역 등 모든 자원이 복제되어 저장됨</li>\n<li>저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재\n<ul>\n<li>c.f. ) 실제로는 fork 직후 같은 프로세스를 <Mark>통째로 메모리에 중복 저장하지 않으면서</Mark> 동시에 프로세스끼리 자원을 공유하지 않는 방법이 있다. 이를 <Mark>쓰기 시 복사(copy on write)기법</Mark>이라 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>thread\n<ul>\n<li>스레드들은 각기 다른 스레드 ID, (별도의 실행을 위해 꼭 필요한) 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/52f79880-1bda-4bac-abd2-e0e0c012361d\" alt=\"image\"></li>\n</ul>\n</li>\n<li>프로세스끼리는 자원을 공유하지 않는다 → 남남처럼 독립적으로 실행\n<ul>\n<li>프로세스 간에도 자원을 주고받을 수 있다 → 프로세스 간 통신(IPC)</li>\n<li>파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신</li>\n<li>c.f.) socket, pipe …</li>\n</ul>\n</li>\n<li>스레드는 프로세스의 자원을 공유 → 비교적 멀티프로세스에 비해 협력과 통신에 유리\n<ul>\n<li>스레드 하나에 문제가 생기면 전체 프로세스에 문제가 생길 수 있음</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"프로세스-확인하기\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"프로세스 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 확인하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">vi test<span class=\"token punctuation\">.</span>py\r\n<span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello, os\"</span><span class=\"token punctuation\">)</span>\r\npython3 test<span class=\"token punctuation\">.</span>py\r\n\r\n<span class=\"token comment\">// PID 확인</span>\r\nvi test<span class=\"token punctuation\">.</span>py\r\n\r\nimport os\r\nos<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// PID 22662</span>\r\n\r\n<span class=\"token comment\">// -----------------------------------</span>\r\nfrom multiprocessing import Process\r\nimport os\r\n\r\ndef <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: child process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 자식 PID</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: paraent process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getppid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 자식의 부모 PID(22784)</span>\r\n\r\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token char\">'__main__'</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'paraent process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// paraent process:  22784</span>\r\n    child <span class=\"token operator\">=</span> <span class=\"token function\">Process</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 자식 프로세스 생성</span>\r\n<span class=\"token comment\">// ------------------------------------</span>\r\n\r\n<span class=\"token comment\">// 멀티 process 생성</span>\r\nfrom multiprocessing import Process\r\nimport os\r\n\r\ndef <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: child process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: paraent process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getppid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token char\">'__main__'</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'paraent process: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    child1 <span class=\"token operator\">=</span> <span class=\"token function\">Process</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    child2 <span class=\"token operator\">=</span> <span class=\"token function\">Process</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n    child3 <span class=\"token operator\">=</span> <span class=\"token function\">Process</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"스레드-확인하기\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0\" aria-label=\"스레드 확인하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스레드 확인하기</h2>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\">vi test<span class=\"token punctuation\">.</span>py\r\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span>\r\nimport threading\r\nimport os\r\n\r\ndef <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: thread id is: '</span><span class=\"token punctuation\">,</span> threading<span class=\"token punctuation\">.</span><span class=\"token function\">get_native_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'foo: my pid is: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> \r\n\t\t<span class=\"token comment\">// 23222, thread는 process의 자원 공유</span>\r\n\r\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token char\">'__main__'</span><span class=\"token operator\">:</span>\r\n    <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token char\">'PID: '</span><span class=\"token punctuation\">,</span> os<span class=\"token punctuation\">.</span><span class=\"token function\">getpid</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 23222</span>\r\n    thread1 <span class=\"token operator\">=</span> threading<span class=\"token punctuation\">.</span><span class=\"token function\">Thread</span><span class=\"token punctuation\">(</span>target<span class=\"token operator\">=</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span><span class=\"token operator\">--</span>\r\n</code></pre></div>\n<h2 id=\"cpu-스케줄링-개요\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EA%B0%9C%EC%9A%94\" aria-label=\"cpu 스케줄링 개요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cpu 스케줄링 개요</h2>\n<p>운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것</p>\n<h3 id=\"프로세스-우선순위\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"프로세스 우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로세스 우선순위</h3>\n<p><Mark>입출력 작업</Mark>이 많은 프로세스(=<Mark>I/O Bound Process</Mark>, 입출력 집중 프로세스)의 우선순위는</p>\n<p><Mark>CPU 작업</Mark>이 많은 프로세스(=<Mark>CPU Bound Process</Mark>, CPU 집중 프로세스)의 우선순위 보다 높다</p>\n<ul>\n<li>I/O Bound Process는 대기 상태에서 더 많이 존재하기에 입출력 작업이 우선순위가 높아서 프로세스 먼저 실행</li>\n</ul>\n<h3 id=\"스케줄링-큐\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%ED%81%90\" aria-label=\"스케줄링 큐 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스케줄링 큐</h3>\n<ul>\n<li>반드시 FIFO일 필요는 ❌</li>\n</ul>\n<p>특정 자원(cpu,hdd, i/o devcie)을 이용하고 싶어하는 프로세스들을 큐에 삽입해서 자원을 이용하도록 만듦</p>\n<ul>\n<li>준비 큐와 대기 큐\n<ul>\n<li>준비 큐: CPU를 이용하기 위해 기다리는 줄</li>\n<li>대기 큐: 입출력장치를 이용하기 위해 기다리는 줄\n<ul>\n<li>같은 장치를 요구한 프로세스들은 같은 큐에서 대기\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/dca033ec-bdaf-4241-a16c-d5189c97c5a9\" alt=\"image\"></li>\n<li>먼저 큐에 삽입되더라도 반드시 먼저 실행되는 것은 아님, 우선순위가 높은 프로세스가 CPU를 이용</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"선점형과-비선점형-스케줄링\" style=\"position:relative;\"><a href=\"#%EC%84%A0%EC%A0%90%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81\" aria-label=\"선점형과 비선점형 스케줄링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선점형과 비선점형 스케줄링</h2>\n<p><strong>선점형 스케줄링(Preemptive)</strong></p>\n<ul>\n<li>현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당</li>\n<li>어떤 프로세스 하나가 CPU 자원 하나를 독점해서 쓸 수 없는 스케줄링 방식</li>\n<li>프로세스마다 정해진 시간만큼 CPU를 쓰게 하고 정해진 시간을 모두써서 타임아웃 인터럽트가 발생하면 OS가 다음 프로세스에게 CPU자원을 넘겨줌</li>\n<li>장점\n<ul>\n<li>어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다</li>\n</ul>\n</li>\n</ul>\n<p><strong>비선점형 스케줄링((Non-preemptive))</strong></p>\n<ul>\n<li>현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기</li>\n<li>어느 한 프로세스가 자원을 이용하고 있다면 종료되거나 대기상태에 접어들기 전까지 다른 끼어들 수 ❌</li>\n<li>장점\n<ul>\n<li>선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다</li>\n</ul>\n</li>\n<li>단점\n<ul>\n<li>모든 프로세스가 골고루 자원을 이용하기 어렵다</li>\n</ul>\n</li>\n</ul>\n<p>c.f. ) 문맥교환\r\n다중 프로그래밍 및 다중 작업 환경에서 발생하는 프로세스 간의 전환 작업을 의미</p>\n<p>문맥 교환은 현재 실행 중인 프로세스의 상태(문맥)를 저장하고, 다음으로 실행될 프로세스의 상태를 복원하는 과정을 포함. 이를 통해 여러 프로세스가 CPU를 공유하며 실행될 수 있습니다.</p>\n<p>문맥 교환은 다음과 같은 상황에서 발생할 수 있음:</p>\n<ol>\n<li>인터럽트: 하드웨어 인터럽트(예: 타이머 인터럽트, 입출력 완료 인터럽트) 또는 소프트웨어 인터럽트(예: 시스템 호출)에 의해 발생.</li>\n<li>스케줄러 결정: <Mark>스케줄러는 실행 중인 프로세스 중 하나를 중단하고 다른 프로세스를 실행하도록 결정할 때 발생</Mark>합니다. 이를 통해 다양한 프로세스 간에 CPU 시간을 공정하게 분배할 수 있음.</li>\n<li>입출력 작업: 입출력 작업을 수행하는 동안 CPU가 대기 상태에 들어가는 경우, 다른 프로세스로 전환하여 시스템 자원을 최대한 활용합니다.</li>\n</ol>\n<p>문맥 교환은 오버헤드를 발생시킬 수 있으므로, 효율적으로 수행하기 위해 하드웨어와 운영 체제가 최적화되어야 한다. 문맥 교환은 다중 프로그래밍 환경에서 여러 작업이 동시에 실행될 수 있도록 해주는 핵심적인 운영 체제 기능 중 하나</p>\n<h2 id=\"cpu-스케줄링-알고리즘\" style=\"position:relative;\"><a href=\"#cpu-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"cpu 스케줄링 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>cpu 스케줄링 알고리즘</h2>\n<ol>\n<li>\n<p>선입 선처리 스케줄링</p>\n<p><strong>FCFS(First Come First Served) 스케줄링</strong></p>\n<ul>\n<li>단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링</li>\n<li>먼저 CPU를 요청한 프로세스부터 CPU 할당</li>\n<li>단점: 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용(=호위 효과)\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/1c69dc56-e150-4184-a615-8404e80b1fd6\" alt=\"image\"></li>\n</ul>\n</li>\n<li>\n<p>최단 작업 우선 스케줄링</p>\n<p><strong>SJF(Shortest Job First) 스케줄링</strong></p>\n<ul>\n<li>호위 효과를 방지하려면</li>\n<li>CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/d7e0510c-a903-43d5-b125-457e10ec52fc\" alt=\"image\"></li>\n<li>CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식\n<ul>\n<li>선점형 → 최소 잔여 시간 우선 스케줄링</li>\n<li>비선점형 → 주로</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>라운드 로빈 스케줄링</p>\n<p><strong>RR(Round Robin) 스케줄링</strong></p>\n<ul>\n<li>선입 선처리 스케줄링 + <Mark>타임 슬라이스(time slice)</li>\n<li>타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간\n<ul>\n<li>타임 슬라이스의 크기가 중요, 너무 커지면 FCFS와 유사해져서 호위 효과가 생길 수도</li>\n<li>너무 작으면 문맥교환이 발생하는 오버헤드 떄문에 CPU 부담이 너무 커짐</li>\n</ul>\n</li>\n<li>정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링\n<ul>\n<li>큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용</li>\n<li>정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입(문맥교환)\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/0a55b185-8bb3-4fef-9548-2c8a3a577545\" alt=\"image\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>최소 잔여 시간 우선 스케줄링</p>\n<p><strong>SRT(Shortest Remaining Time) 스케줄링</strong></p>\n<ul>\n<li>최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링</li>\n<li>최단 작업 우선 스케줄링: 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘</li>\n<li>라운드 로빈 스케줄링: 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘</li>\n<li>정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 <Mark>남은 작업 시간이 가장 적은 프로세스 선택</li>\n</ul>\n</li>\n<li>\n<p>우선순위 스케줄링</p>\n<ul>\n<li>프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행</li>\n<li>우선순위가 같은 프로세스들은 선입 선처리로 스케줄링</li>\n<li>최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 C 우선 순위 스케줄링\n<ul>\n<li>최단작업우선스케줄링: 작업시간이 짧은 프로세스한테 높은 우선수위를 부여하는 방식</li>\n<li>최소잔여시간스케줄링: 남아있는 시간이 짧은 프로세스한테 높은 우선순위를 부여하는 방식</li>\n</ul>\n</li>\n<li>우선순위 스케줄링의 근본적인 문제점, <Mark>기아(starvation)현상</li>\n<li>우선순위 높은 프로세스만 주구장창 실행</li>\n<li>우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기</li>\n<li>기아현상을 방지하기 위한 기법: <Mark>에이징(aging)</li>\n<li>오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식</li>\n<li>대기 중인 프로세스의 우선순위를 점차 증가시키는 방법\n<ul>\n<li>우선순위가 낮아도 언젠가는 우선순위가 높아진다</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>다단계 큐 스케줄링</p>\n<p><strong>Multilevel queue 스케줄링</strong></p>\n<ul>\n<li>우선순위 스케줄링의 발전된 형태</li>\n<li>우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식\n<ul>\n<li>우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리</li>\n<li>우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/dd6f2ca2-8b02-4995-81b3-62b5907b9989\" alt=\"image\"></li>\n<li>큐 간의 이동이 불가, 우선순위가 낮은 프로세스는 우선순위가 낮은 큐에서 높은 큐로 이동 불가능하므로 <Mark>기아현상</Mark> 발생 가능</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>다단계 피드백 큐 스케줄링</p>\n<p><strong>Multilevel feedback queue 스케줄링</strong></p>\n<ul>\n<li>다단계 큐 스케줄링의 발전된 형태</li>\n<li>큐 간의 이동이 가능한 다단계 큐 스케줄링</li>\n<li>다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동 불가\n<ul>\n<li>우선순위 낮은 프로세스는 계속해서 실행 연기 우려</li>\n<li>기아 현상 발생 가능\r\n<img src=\"https://github.com/boost-library/yong-study/assets/74396128/d36488cf-0cbc-4c6c-92df-d25d060ca790\" alt=\"image\"></li>\n</ul>\n</li>\n<li>준비상태의 프로세스를 가장 높은 우선순위 큐에 삽입, 차례가 오면 CPU할당 받고 실행, 실행이 안끝났으면 다음 실행 우선순위 큐로 이동해서 실행.. 스케줄링의 반복. 타임 슬라이스 동안 실행을 다 못 끝내면 낮은 우선순위로 이동\n<ul>\n<li>자연스럽게 CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고\n<ul>\n<li>다단계 피드백 큐에서도 에이징 기법 적용 가능 →  기아현상 해결 가능</li>\n</ul>\n</li>\n<li>입출력 집중 프로세스의 우선순위는 상대적으로 높아짐</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<p>즉, 어떤 프로세스의 CPU 시간이 길면 우선순위가 낮아지고 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식</p>\n<p>일반적인 CPU 스케줄링 방식으로 알려져 있음</p>","fields":{"slug":"/posts/2023-09-12---프로세스와 스레드//posts/os/process-thread","tagSlugs":["/tag/os/","/tag/cs/"]},"frontmatter":{"date":"2023-09-12T20:35:32.169Z","description":"프로세스와 스레드에 대해서 배웁니다","tags":["OS","CS"],"title":"프로세스와 스레드","socialImage":null}}},"pageContext":{"slug":"/posts/2023-09-12---프로세스와 스레드//posts/os/process-thread"}},"staticQueryHashes":["2236276093","251939775","401334301"]}