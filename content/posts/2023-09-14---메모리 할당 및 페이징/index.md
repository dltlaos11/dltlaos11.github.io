---
title: 메모리 할당 및 페이징
date: "2023-09-14T20:35:32.169Z"
template: "post"
draft: false
slug: "/posts/os/memory-allocation&paging"
category: "OS"
tags:
  - "OS"
  - "CS"  
description: "메모리 할당 및 페이징에 대해서 배웁니다"
---

- [연속 메모리 할당](#연속-메모리-할당)
    - [스와핑](#스와핑)
    - [메모리 할당](#메모리-할당)
    - [외부 단편화](#외부-단편화)
- [페이징을 통한 가상 메모리 관리](#페이징을-통한-가상-메모리-관리)
    - [페이징](#페이징)
    - [페이지 테이블](#페이지-테이블)
    - [PTBR](#ptbr)
    - [TLB](#tlb)
    - [페이징에서의 주소 변환](#페이징에서의-주소-변환)
    - [페이지 테이블 엔트리](#페이지-테이블-엔트리)
- [페이지 교체와 프레임 할당](#페이지-교체와-프레임-할당)
    - [요구 페이징](#요구-페이징)
    - [페이지 교체 알고리즘](#페이지-교체-알고리즘)
    - [스래싱과 프레임 할당](#스래싱과-프레임-할당)
- [페이징의 이점과 계층적 페이징](#페이징의-이점과-계층적-페이징)
    - [쓰기 시 복사](#쓰기-시-복사)
    - [계층적 페이지](#계층적-페이지)

## 연속 메모리 할당

![image](https://github.com/boost-library/yong-study/assets/74396128/32ac8300-3bb5-4504-9f7c-e9927ce6c95f)

프로세스에 연속적인 메모리 공간을 할당

### 스와핑

현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역(<Mark>스왑 영역</Mark>)으로 쫓아내고, 그렇게 생긴 빈 공간에 새 프로세스 적재
    ![image](https://github.com/boost-library/yong-study/assets/74396128/c96b4cf5-f5a0-4461-8db9-896656bb5b7a)
        → 당장 사용할 수 있는 프로세스만 메모리(<Mark>스왑 인</Mark>)에 배치 가능, 메모리에서 보조기억장치로 프로세스 이동(<Mark>스왑 아웃</Mark>)

스와핑을 통해 프로세스들이 요구하는 메모리 공간 크기가 메모리보다 큰 경우 적절한 메모리 적재가 가능
    ![image](https://github.com/boost-library/yong-study/assets/74396128/ae060b26-5f8d-40ba-a503-a8c6e9224584)
- 스왑 영역 크기 확인: free, top

### 메모리 할당

- 프로세스는 메모리의 빈 공간에 할당되어야 한다.
    - 최초 적합, 최적 적합, 최악 적합 → <Mark>연속 메모리 할당 방식
        
        - 연속적으로 프로세스를 메모리에 내에 배치할 떄 어떤 빈 공간에 어떻게 적재할지에 따라서 나뉜 방식
    - 최초 적합(first-fit)
        - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
    - 최적 적합(best-fit)
        - 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
        - 외부 단편화 발생 가능성 크다
    - 최악 적합(worst-fit)
        - 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당
        - 외부 단편화 발생 가능성 적다

### 외부 단편화

프로세스를 연속적으로 할당하는 방식은 메모리를 효율적으로 사용하는 방법이 아니다. 

외부 단편화**external fragmentation**라는 문제가 발생하기 때문 

- <Mark>프로세스들이 실행되고 종료되길 반복하며 메모리 사이에 빈 공간 발생
- <Mark>외부 단편화
    
    - 프로세스를 할당하기 어려울 만큼 <Mark>작은 메모리 공간들</Mark>로 인해 <Mark>메모리가 낭비</Mark>되는 현상
- 외부 단편화 해결
    1. 메모리 압축(compaction)
        - 흩어져 있는 빈 공간들을 하나로 모으는 방식
        - 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
        - 부작용
            - 빈 공간을 하나로 압축시키는 과정과, 프로세스들을 재배치하는 과정에서 오버헤드 발생
    2. 가상 메모리 기법, 페이징

## 페이징을 통한 가상 메모리 관리

연속 메모리 할당의 두 가지 문제점

- 외부 단편화
- 물리 메모리보다 큰 프로세스 실행 불가

가상 메모리

- 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
- 페이징, 세그멘테이션

### 페이징

- 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문에 외부 단편화  발생
- 메모리에 적재되는 대상이 모두 일정한 크기를 갖고 있다면 외부 단편화 발생 ❌
- 페이징은 프로세스를 일정한 크기로 자르고, 이를 메모리에 불연속적으로 할당하여 외부 단편화를 해결한다
- 프로세스의 <Mark>논리 주소 공간을 페이지(page)</Mark>라는 일정 단위로 자르고,
- 메모리의 <Mark>물리 주소 공간을 프레임(frame)</Mark>이라는 페이지와 동일한 일정한 단위로 자른 뒤
- <Mark>페이지를 프레임에 할당하는 가상 메모리 관리 기법
    ![image](https://github.com/boost-library/yong-study/assets/74396128/19e5c44a-42dd-49a2-aa28-2a49377c733d)
- 페이징에서의 스와핑
    - 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(<Mark>페이지 인</Mark>), 스왑 아웃(<Mark>페이지 아웃</Mark>)
    - 메모리에 적재된 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
    - 실행에 필요한 페이지들은 메모리로 스왑 인
        ![image](https://github.com/boost-library/yong-study/assets/74396128/9114af0d-6764-416c-a5c6-6e6b6fd833c9)
    - 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없다
    - 달리 말해 <Mark>물리 메모리보다 큰 프로세스도</Mark> 실행 가능

### 페이지 테이블

- 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기란 어렵다
- 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 ❌
- CPU입장에서 ‘다음에 실행할 명령어 위치’를 찾기가 어려워짐
- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인)논리 주소에는 연속적으로 배치되도록 하는 방법
- <Mark>페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
- 프로세스마다 페이지 테이블이 있다
    ![image](https://github.com/boost-library/yong-study/assets/74396128/021409ee-3f14-4a98-9b97-17231c42f184)
- 물리적으로는 분산되어 저장되더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보임
- <Mark>CPU는 그저 논리 주소를 순차적으로 실행하면 될 뿐
- 내부 단편화
    - 페이지 크기가 10KB, 프로세스 크기 108KB일 경우
    - <Mark>2KB: 내부 단편화
    - 하나의 페이지 크기보다 작은 크기로 발생
    - 세그멘테이션 해결 가능 → 외부단편화 발생
        ![image](https://github.com/boost-library/yong-study/assets/74396128/1cf3a22a-d0d8-4121-9ae9-bfb6faee9018)

### ptbr

- 프로세스마다 페이지 테이블이 있고, 각 페이지 테이블은 CPU내의 <Mark>프로세스 테이블 베이스 레지스터(PTBR)</Mark>가 가리킨다(저장).
    ![image](https://github.com/boost-library/yong-study/assets/74396128/a71f5f98-a406-4fdb-b2ed-37b64d4374fb)
    프로세스 B 실행 시 PTBR은 프로세스 B의 페이지테이블 주소를 가리키고 이를 통해 CPU는 B의 페이지테이블에 접근해서 프로세스 B의 페이지가 각각 어떤 프레임에 할당되어 있는지 알 수 있다
- 그런데, 페이지 테이블이 메모리에 있다면 <Mark>메모리 접근 시간이 두배로 걸리는 문제가 생김

    - 페이지 테이블(어떤 페이지가 어떤 프레임에 할당되어있는지 알 수 있다) 참조하기 위해 한번
    - 페이지 참조하기 위해 한번
### tlb

- CPU 곁에 페이지 테이블의 캐시 메모리
- 페이지 테이블의 일부를 가져와 저장하여 불필요한 메모리 접근을 줄일 수 있다
- CPU가 접근하려는 논리 주소가 TLB에 있다면 → TLB 히트
    - 메모리 접근 1번
- CPU가 접근하려는 논리 주소가 TLB에 없다면 → TLB 미스
    - 메모리 접근 2번
        ![image](https://github.com/boost-library/yong-study/assets/74396128/cd7e653f-6dd9-4570-b7b1-057f8e16afdd)

### 페이징에서의 주소 변환

- 특정 주소에 접근할 때 필요한 정보
    - 어떤 페이지/프레임에 접근하고 싶은지
    - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 <Mark>얼마나 떨어져 있는지
- 페이징 시스템에서의 논리 주소
    - 페이지 번호(page number)와 변위(offset)
- <Mark><페이지 번호, 변위></Mark>로 이루어진 논리 주소는 페이지 테이블을 통해 <Mark><프레임 번호, 변위></Mark>로 이루어진 물리주소로 변환
    - 논리주소에서의 변위와 물리주소에서의 변위는 <Mark>같다
        ![image](https://github.com/boost-library/yong-study/assets/74396128/36004ddb-27a5-4e54-88a9-2f1330ae98c7)

### 페이지 테이블 엔트리

- 페이지 테이블 각각의 행: 페이지 테이블 엔트리(PTE)
    - PTE에는 페이지 번호, 프레임 번호 등이 있으며 이외에도 여러가지 정보가 있음
        - 유효비트
            - 현재 해당 페이지에 접근 가능한지 여부
                - 현재 페이지가 스왑 영역으로  스왑아웃 되있는지 아닌지, 메모리에 적재되어 있는지 아닌지를 나타낸다
                    ![image](https://github.com/boost-library/yong-study/assets/74396128/0fc11f87-f1f4-4735-81ba-350858a873cd)
                    - 유효 비트가 0인 페이지(메모리에 적재❌)에 접근하는 경우
                        - 페이지 폴트(page fault)라는 인터럽트 발생
                            1. CPU는 기존의 작업 내용을 백업
                            2. 페이지 폴트 처리 루틴(<Mark>인터럽트 서비스 루틴</Mark>)을 실행
                            3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
                            4. 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근할 수 있음
        - 보호 비트
            - 페이지 보호 기능을 위해 존재하는 비트 
                ![image](https://github.com/boost-library/yong-study/assets/74396128/275f2846-329a-43a7-bd5b-046d98310b91)
                    
                - c.f. )프로세스의 코드 영역은 read-only영역, 읽기만 가능하므로 쓰기 권한
                - 페이지에 접근할 권한을 제한하여 페이지를 보호하는 비트
        - 참조 비트
            - CPU가 이 페이지에 접근한 적이 있는지 여부
                ![image](https://github.com/boost-library/yong-study/assets/74396128/b2091785-2d8f-4154-974d-6a1f26287f63)
        - 수정 비트(=dirty bit)
            - CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
                ![image](https://github.com/boost-library/yong-study/assets/74396128/c6528fbf-7e16-4582-ac40-ca44915f7320)
            - 수정비트의 존재 이유 → 스와핑
                - 페이지가 메모리에서 삭제될 때 보조기억장치의 쓰기작업을 해야 되는지 여부를 판단하기 위해서 존재
                - 만약 CPU 페이지의 내용을 변경했다면(쓰기) 해당 페이지는 스왑 아웃될 때 변경된 내용을 보조기억장치에도 반영해야(쓰기) 한다 → 수정 비트를 통해서 판단

## 페이지 교체와 프레임 할당

물리 메모리보다 큰 프로세스를 실행할 수 있지만, 그럼에도 <Mark>물리 메모리의 크기는 한정</Mark>되어 있다

- 기존에 적재된 불필요한 페이지를 선별해 보조기억장치로 내보내야하고 → <Mark>페이지 교체 알고리즘
- 프로세스들에게 적절한 수의 프레임을 할당해야 한다 → <Mark>프레임 할당

### 요구 페이징

- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- <Mark>요구되는 페이지만</Mark> 적재하는 기법
    1. CPU가 특정 페이지에 접근하는 명령어를 실행
    2. 해당 페이지가 현재 메모리에 있을 경우(<Mark>페이지 테이블 엔트리에 유효비트가 1일 경우</Mark>) CPU는 페이지가 적재된 프레임에 접근
    3. <Mark>**해당 페이지가 현재 메모리에 없을 경우**(유효비트:0)</Mark> <Mark>페이지 폴트</Mark>가 발생
    4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정
    5. 다시 1️⃣을 수행
- c.f.) 어떤 프로세스를 실행하고자 할 때 어떤 페이지도 적재하지 않은채 실행하는 기법을 <Mark>순수 요구 페이징</Mark>이라 함
- 요구 페이징 시스템이 안정적으로 작동하려면 <Mark>페이지 교체</Mark>와 <Mark>프레임 할당</Mark>을 해야 함

### 페이지 교체 알고리즘

- 요구 페이징 기법으로 페이지들을 적재하다보면 언젠가 메모리가 가득 차게 된다
- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 하는데 <Mark>어떤 페이지를</Mark> 내보내는 방법(알고리즘)이 <Mark>페이지 교체 알고리즘
- <Mark>페이지 폴트가 적은 알고리즘</Mark>이 좋은 페이지 교체 알고리즘🔥
    - 페이지 폴트가 발생하면 보조기억장치로부터 필요한 페이지를 다시 갖고와야 하므로 메모리에 적재된 페이지를 가지고 오는 것보다 느려지기 떄문 → 보조기억장치에 접근해야 해서 성능 저하
        - e.g. ) 어떤 페이지 교체 알고리즘을 통해서 페이지를 스왑아웃시켰더니 페이지 폴트가 자주 발생  == 보조기억장치로 내보내야 할 페이지를 잘 못 골랐다, 내보내면 안되는 페이지를 보조기억장치로 내보냄
        - e.g. ) 어떤 페이지 교체 알고리즘을 통해 고른 페이지를 스왑아웃시켜도 페이지폴트가 자주 발생하지 않는다면 보조기억장치로 내보낼 페이지를 잘 골랐음을 의미
- 페이지 폴트 횟수
    - 페이지 참조열(page reference string)
        - CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
            - e.g. )2 2 2 3 5 5 5 3 3 7 → 2 3 5 3 7
- FIFO 페이지 교체 알고리즘
    - 가장 단순한 방식
    - 메모리에 가장 먼저 올라온 페이지부터 내보내는 방식
        ![image](https://github.com/boost-library/yong-study/assets/74396128/55266032-0a5d-4dc5-8d73-e6ce40ce3469)
    - 프로그램 실행 초기에 잠깐 실행될 페이지
    - <Mark>프로그램 실행 내내 사용될 페이지</Mark> ← 먼저 적재되었다고 내보내면 ❌
- FIFO 페이지 교체 알고리즘 - 보완책
    - <Mark>2차 기회(second-chance) 페이지 교체 알고리즘
    - 참조 비트 1: CPU가 한 번 참조한 적이 있는 페이지 → 바로 내보내지 않고 참조 비트를 0으로 초기화 후 적재된 시간을 현재 시간으로 설정하고 가장 최근에 적재된 페이지로 간주
    - 참조 비트 0: CPU가 참조한 적이 없는 페이지 →  가장 오랬동안 메모리에 머물렀음에도 CPU가 참조한 적이 없음을 의미하므로 내보냄
        ![image](https://github.com/boost-library/yong-study/assets/74396128/ba7d2b7f-6d8c-482b-9812-0c7ce3d39497)
        </br>
        ![image](https://github.com/boost-library/yong-study/assets/74396128/255c0d2d-d4f7-46d9-b426-77679fb7f8aa)
- 최적 페이지 교체 알고리즘
    - CPU에 의해 참조되는 횟수를 고려
    - 메모리에 오래 남아야 할 페이지는 <Mark>자주 사용될 페이지
    - 메모리에 없어도 될 페이지는 오랫동안 <Mark>사용되지 않을 페이지
    - 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
        ![image](https://github.com/boost-library/yong-study/assets/74396128/b2af5866-39da-49fd-89e8-808ec778fc06)
    - <Mark>가장 낮은 페이 폴트율을 보장</Mark>하는 페이지 교체 알고리즘
    - <Mark>실제 구현이 어렵다</Mark> → 예측할 수 ❌
    - 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주
- LRU(Least-Recently-Used) 페이지 교체 알고리즘
    - 최적 페이지 교체 알고리즘: 가장 오래 사용되지 <Mark>않을</Mark> 페이지 교체
    - LRU 페이지 교체 알고리즘: 가장 오래 사용되지 <Mark>않은</Mark> 페이지 교체
        - “최근에 사용되지 않은 페이지는 앞으로도 사용되지 않지 않을 것..”
            ![image](https://github.com/boost-library/yong-study/assets/74396128/71db495a-3ff0-42ee-81e9-8d1e8aabdece)
- 기타 페이지 교체 알고리즘
    - 이외에도 많은 페이지 교체 알고리즘이 존재(e.g. LRU 페이지 교체 알고리즘의 파생 알고리즘)
- 페이지 교체 알고리즘이란 무엇인지
- 페이지 교체는 왜 해야 하는지
- 무엇이 좋은 페이지 교체 알고리즘인지
### 스래싱과 프레임 할당

- 페이지 폴트가 자주 발생하는 이유
    - 나쁜 페이지 교체 알고리즘을 사용해서
    - <Mark>프로세스가 사용할 수 있는 프레임 자체가 적어서, 많으면 상대적으로 자주 일어나지 않을 것
- 스래싱
    - 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제
        ![image](https://github.com/boost-library/yong-study/assets/74396128/ead703e8-3ff7-43ef-aba6-c470835a53e2)
    - 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것이 아니다
    - 페이지 폴트가 너무 빈번하게 발생하기 때문에 막상 실행해야 하는 프로세스를 실행하지 못하는 상태
        ![image](https://github.com/boost-library/yong-study/assets/74396128/c33d9220-ad92-415d-b002-8ebde9e8f386)
        - 멀티프로그래밍의 정도: 메모리에 동시에 실행되는 프로세스의 수
    - 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문
    - <Mark>각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 함

- 운영체제의 프레임 할당 방식
    - 균등 할당(equal allocation)
        - 가장 단순한 할당 방식
        - <Mark>모든 프로세스들에게 균등하게 프레임을 할당하는 방식 → 실행되는 프로세스들의 크기는 각기 다를텐데 동일한 프레임의 수를 할당하는 방식은 비합리적
    - 비례 할당(proportional allocation)
        - 프로세스의 크기를 고려
        - <Mark>프로세스 크기에 비례하여 프레임 할당 방식
        - 크기가 큰 프로세스인데 막상 실행해보니 많은 프레임을 필요로 하지 않을 수도있고 크기가 작은 프로세스인데 막상 실행해보니 많은 프레임을 필요로 할 수 도 있음 → 결국 프로세스가 필요로 하는 프레임 수는 <Mark>실행해봐야 알 수 있음
    
    c.f.) 균등, 비례 할당은 프로세스의 실행 과정을 고려하지 않고 프로세스의 크기나 물리 메모리의 크기만 고려한 방식이라는 점에서  <Mark>정적 할당 방식</Mark>이라 부르기도
    
    - 작업 집합 모델(Working set Model)
        - 프로세스가 실행하는 과정에서 배분할 프레임 결정
        - 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
            - 그렇다면 <Mark>CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당</Mark>하면 된다
        - ‘프로세스가 일정 기간 동안 참조한 페이지 집합’을 기억하여 빈번한 페이 교체를 방지하는 방식이 작업 집합 모델 기반의 프레임 할당 방식
            - <Mark>작업 집합</Mark>이란 “실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합”을 의미
        - 작업 집합을 구하려면
            1. 프로세스가 참조한 페이지
            2. 시간 간격이 필요
                ![image](https://github.com/boost-library/yong-study/assets/74396128/f3f3ee0d-d97e-4bd6-9282-ed3541a9514d)
                최소 5개의 프레임이 t2라는 순간에 필요 → 작업 집합 모델 기반의 프레임 할당 방식
    - 페이지 폴트 빈도
        - 프로세스가 실행하는 과정에서 배분할 프레임 결정
        - 두 개의 가정에서 생겨난 아이디어
            1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다
            2. 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다
                ![image](https://github.com/boost-library/yong-study/assets/74396128/0bf93504-be6e-419d-add9-c6650cf4e5cd)
                - 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식

    c.f.) 작업 집합 모델, 페이지 폴트 빈도: <Mark>동적 할당 방식</Mark> → 프로세스가 실행하는 과정을 통해서 프레임을 할당하는 방식
## 페이징의 이점과 계층적 페이징

### 쓰기 시 복사

페이징 → 외부 단편화 해결 가능, 프로세스 간 페이지 공유 가능(**쓰기 시 복사,** 공유 라이브러리)

- 이론적인 fork()
    - 프로세스는 기본적으로 자원을 공유하지 ❌
        
        → 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통째로 복제되어 적재(<Mark>프로세스 생성 시간 지연, 메모리 낭비</Mark>)
            ![image](https://github.com/boost-library/yong-study/assets/74396128/a5c20ba4-9dcb-4555-a251-752e4d9d2573)
- 쓰기 시 복사
    - 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면 자식 프로세스는 부모 프로세스와 <Mark>동일한 프레임</Mark>을 가리킴(<Mark>쓰기 작업 없다면 이 상태 유지</Mark>)
        ![image](https://github.com/boost-library/yong-study/assets/74396128/d050921c-7473-43da-a0b1-b935e1100d53)
    - 프로세스 간 기본적으로는 자원을 공유 ❌ → <Mark>부모 프로세스/자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시</Mark> 해당 페이지는 별도의 공간으로 복제(<Mark>프로세스 생성 시간 절약, 메모리 절약</Mark>) 
        ![image](https://github.com/boost-library/yong-study/assets/74396128/8d2d048d-782a-4953-8db0-9802cc7a18d7)
        - 부모 프로세스와 자식 프로세스가 별도의 자원을 유지하면서 중복해서 메모리를 저장❌ (메모리 효율 & 프로세스 간 자원 공유를 막는 방식 → <Mark>쓰기 시 복사</Mark>)
### 계층적 페이지

- 프로세스 테이블의 크기는 생각보다 작지 않다
- 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 낭비
- 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 방법
- <Mark>페이지 테이블을 페이징</Mark>하여 여러 단계의 페이지를 두는 방식
    ![image](https://github.com/boost-library/yong-study/assets/74396128/c1936155-89a9-4630-a5ae-0ea4703436b3)
    - 페이지 테이블을 여러 페이지로 쪼개고 이 페이지를 가리키는 페이지 테이블(Outer 페이지 테이블)을 두는 방식
- 모든 페이지 테이블을 항상 메모리에 있을 필요가 없어짐
    - CPU와 가장 가까이 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지
- 계층적 페이징을 이용하는 환경에서의 논리 주소
    - <Mark>바깥 페이지 번호 + 안쪽 페이지 번호 + 변위(2단계, 이상의 단계도 가능)

        1. 바깥 페이지 번호를 통해 <Mark>페이지 테이블의 페이지</Mark>를 찾기
        2. <Mark>페이지 테이블의 페이지</Mark>를 통해 <Mark>프레임 번호</Mark>를 찾고 변위를 더함으로서 물리 주소 얻기
        
        c.f.) 계층이 많을 경우, 페이지 폴트(참조하고자 하는 페이지가 현재 메모리에 존재하지 않는 경우)가 발생했을 경우에 메모리를 많이 참조해야 하기 때문에 계층이 많다고 해서 반드시 좋은 것은 ❌