---
title: 프로세스의 동기화와 교착상태
date: "2023-09-13T20:35:32.169Z"
template: "post"
draft: false
slug: "/posts/os/process-synchronization-deadlock"
category: "OS"
tags:
  - "OS"
  - "CS"  
description: "프로세스의 동기화와 교착상태에 대해서 배웁니다"
---

- [프로세스 동기화](#프로세스-동기화)
    - [동기화의 의미](#동기화의-의미)
    - [공유 자원과 임계 구역](#공유-자원과-임계-구역)
- [동기화 기법](#동기화-기법)
    - [뮤텍스 락](#뮤텍스-락)
    - [세마포어](#세마포어)
    - [모니터](#모니터)
- [교착 상태](#교착-상태)
    - [자원 할당 그래프](#자원-할당-그래프)
- [교착 상태 해결 방법](#교착-상태-해결-방법)
    - [교착 상태 예방](#교착-상태-예방)
    - [교착 상태 회피](#교착-상태-회피)
    - [교착 상태 검출 후 회복](#교착-상태-검출-후-회복)
    - [교차상태 무시](#교차상태-무시)


## 프로세스 동기화

동시다발적으로 실행되는 프로세스들은 서로 협력하며 영향을 주고 받는다, 이 과정에서 <Mark>동기화</Mark>(=자원의 일관성)를 보장해야 한다

### 동기화의 의미

공동의 목적을 위해 동시에 수행되는 프로세스

- e.g. 워드 프로세서 프로그램
    - 맞춤법 검사 프로세스
    - 입력 내용을 화면에 출력하는 프로세스
    - …

→ 아무렇게나 실행하면 ❌ → 올바른 수행을 위해 프로세스들은 <Mark>동기화</Mark>되어야 → 자원의 일관성

프로세스들의 <Mark>수행 시기를 맞추는 것

<Mark>실행 순서 제어</Mark>: 프로세스를 올바른 순서대로 실행하기

- 실행 순서 제어를 위한 동기화: reader writer problem
    - Writer: Book.txt파일에 값을 저장하는 프로세스
    - Reader: Book.txt파일에 저장된 값을 읽어들이는 프로세스
    - Reader와 Writer 프로세스는 무작정 아무렇게나 실행 되면 ❌, <Mark>실행의 순서</Mark> 떄문
- Reader 프로세스는 ‘Book.txt 안에 값이 존재한다’는 <Mark>특정 조건이 만족되어야만</Mark> 실행 가능

<Mark>상호 배제</Mark>: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기

- 상호 배제를 위한 동기화: Bank account problem
- <Mark>한 번에 하나의 프로세스만 접근해야 하는 자원</Mark>에 동시 접근을 피하기 위한 동기화
    - 현재 계좌에 잔액: 10만원
    - 프로세스 A는 현재 잔액에 2만원을 추가하는 프로세스
    - 프로세스 B는 현재 잔액에 5만원을 추가하는 프로세스
        - 동시에 실행된다면 아래와 같은 문제 발생
            ![image](https://github.com/boost-library/yong-study/assets/74396128/a3a2394b-8e6d-4e28-9c63-afa6021a6ea3)
        - 동기화 된 프로세스의 실행 예제
            ![image](https://github.com/boost-library/yong-study/assets/74396128/de95d343-0d22-46e3-a8dd-e090f2d2fa87)

<Mark>Producer & Consumer problem

- 물건을 계속해서 생산하는 생성자(producer, 프로세스 혹은 스레드)
- 물건을 계속해서 생산하는 소비자(consumer, 프로세스 혹은 스레드)
- ‘총합’ 변수 공유
    ```c
    총합= 10
    생산자() {
        버퍼에 데이터 삽입
        '총합' 변수 1 증가
    }

    소비자() {
        버퍼에 데이터 삽입
        '총합' 변수 1 감소
    }
    동기화가 되지 않아 소비자, 생산자를 100,000번 실행하면 총합은 달라짐
    동시에 접근해서는 안되는 자원에 동시에 접근해서 발생한 문제
    ```
c.f. ) 실행의 문맥을 갖는 모든 대상은 동기화 대상이기에 <Mark>스레드</Mark> 또한 동기화 대상

### 공유 자원과 임계 구역

<Mark>공유 자원</Mark>: 여러 프로세스 혹은 스레드가 공유하는 자원

- 전역 변수, 파일, 입출력장치, 보조기억장치, …

<Mark>임계 구역</Mark>: 동시에 실행하면 문제가 발생하는 자원에 접근하는 <Mark>코드 영역

- 앞선 예시의 ‘총합’ 변수 …
- 임계 구역에 진입하고자 하면 진입한 프로세스 이외에는 대기해야
    ![image](https://github.com/boost-library/yong-study/assets/74396128/90d59066-667f-4d46-bfe1-d360ad472959)
- 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있다. 이를 <Mark>경쟁 조건</Mark>(race condition)이라 한다.

운영체제가 임계구역 문제를 해결하는 세 가지 원칙🔥

(상호 배제를 위한 동기화를 위한 세 가지 원칙)

1. <Mark>상호 배제</Mark>mutual exclusion
    
    한 프로세스가 임계구역에 진입했다면 다른 프로세스는 들어올 수 ❌
    
2. <Mark>진행</Mark>progress
    
    임계 구역에 어떤 프로세스도 진입하지 않았다면 <Mark>진입하고자 하는 프로세스는 들어갈 수 있어야 한다
    
3. <Mark>유한 대기</Mark>bounded waiting
    
    한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다(임계구역에 들어오기 위해 무한정 대기해서는 안 된다.)

## 동기화 기법

동기화 기법 중 뮤텍스 락, 세마포어, 모니터에 대해서 알아보자

### 뮤텍스 락

상호 배제를 위한 동기화 도구(자물쇠 역할), 뮤텍스 락

뮤텍스 락의 단순한 형태

- 전역 변수 하나, 함수 두개
- 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
- 임계 구역을 잠그는 역할: acquire 함수
- 임계 구역의 잠금을 해제하는 역할: release 함수

    ```c
    acquire() {
        while (lock == true) // 만약 임계 구역이 잠겨 있다면
                ; // 임계 구역이 잠겨 있는지를 반복적으로 확인
        lock = true; // 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금
    }

    release() {
        lock = false; // 임계 구역 작업이 끝났으니 잠금 해제
    }

    acquire(); // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
    // 임계구역  // 임계 구역에서의 작업 진행
    release() // 자물쇠 반환
    ```
    - acuire 함수
        - 프로세스가 임계 구역에 진입하기 전에 호출
        - 임계 구역이 잠겨 있다면
            - 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인
        - 임계 구역이 열려있다면
            - 임계 구역을 잠그기(lock를 true로 바꾸기)
        - 바쁜 대기(busy waiting)
            ```c
                while (lock == true) // 만약 임계 구역이 잠겨 있다면
                ; // 임계 구역이 잠겨 있는지를 반복적으로 확인
            ```
            - 반복적으로 무한히 대기하면서 임계 구역이 잠겨 있는지를 반복적으로 확인
    - release 함수
        - 임계 구역에서의 작업이 끝나고 호출
        - 현재 잠긴 임계 구역을 열기(lock을 false로 바꾸기)
    
### 세마포어

일반화된 방식의 동기화 도구

<Mark>공유 자원이 여러 개 있는 경우에도</Mark> 적용 가능

세마포어의 종류(이진 세마포어, 카운팅 세마포어) 중 카운팅 세마포어

임계구역 앞에서 멈춤 신호를 받으면 잠시 기다리기

임계구역 앞에서 가도 좋다는 신호를 받으면 임계 구여 진입

세마포어의 단순한 형태

- 전역 변수 하나, 함수 두개
- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 <Mark>전역 변수 S
- 임계구역에 들어가도 좋은지, 기다려야 할지를 알려주는 <Mark>wait함수
- 임계구역 앞에서 기다리는 프로세스에 ‘이제 가도 좋다’고 신호를 주는 <Mark>signal 함수
    ```c
        wait()
        // 임계구역
        signal()
    ```
    ```c
        wait() {
            while(S <= 0) // 만일 임계 구역에 진입할 수 잇는 프로세스 개수가 0 이하라면
                        ; // 사용할 수 있는 자원이 있는지 반복적으로 확인하고
            S--; // 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1감소시키고 임계 구역 진입
        }
    ```
    - Busy waiting
        - CPU 사이클 낭비 → 해결(<Mark>대기 상태, 준비 상태</Mark>)
        - 프로세스 상태를 바꿈으로서 CPU 사이클 낭비를 방지
            - 사용할 수 있는 자원이 없을 경우 <Mark>대기 상태</Mark>로 만듦
                - 해당 프로세스의 PCB를 대기 큐에 삽입
            - 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 <Mark>준비 상태</Mark>로 만듦
                - 해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입
    ```c
        wait() {
            S--;
            if (S < 0) {
                add this process to Queue; // 해당 프로세스 PCB를 대기 큐에 삽입
                sleep(); // 대기 상태로 접어든다
            }
        }
        signal(){
            S++; // 임계 구역에서의 작업을 마친 뒤 S를 1증가
            if (S <= 0) {
                remove a proccess p from Queue // 대기 큐에 있는 프로세스 p를 제거
                wakeup(p) // 프로세스 p를 대기 상태에서 준비 상태로 만든다
            }
        }
    ```

    세마포어를 활용한 실행 <Mark>순서 동기화

    - 세마포어의 변수 S를 <Mark>0</Mark>으로 두고
    - 먼저 실행할 프로세스 <Mark>뒤에 signal</Mark> 함수,
    - 다음에 실행할 프로세스 <Mark>앞에 wait 함수를</Mark> 붙이면 됨

### 모니터

매번 임계구역 앞뒤로 `wait()`, `signal()`을 호출해야하는 번거로움

사용자(개발자)가 다루기에 편한 동기화 도구

**상호 배제를 위한 동기화**

- 인터페이스를 위한 큐
- 공유자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
- 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만)  공유 자원 이용
    ![image](https://github.com/boost-library/yong-study/assets/74396128/5b1d247e-b64a-49a0-a17a-696c6867ad00)

**실행 순서 제어를 위한 동기화**

- 조건 변수condition variable 이용
    - condition variable: 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
        ![image](https://github.com/boost-library/yong-study/assets/74396128/569bcfbd-c50a-4958-8e1e-e76c601201b8)
- 조건변수.wait(): 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
- 조건변수.signal(): wait()으로 대기 상태로 접어든 조건 변수를 실행 상태로 변경

모니터 안에는 하나의 프로세스만이 있을 수 있다

- wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재게
- signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal()을 호출한 프로세스의 수행을 재게

실행 순서 제어를 위한 동기화

1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행 중단
2. 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재게

## 교착 상태

**두 개 이상의 프로세스가 서로 상대방이 가지고 있는 자원을 기다리면서 무한정 대기하게 되는 상황**

### 자원 할당 그래프

1. 교착 상태가 발생했을 때의 상황을 정확히 표현해보기

교착 상태 발생 조건 파악가능

- 어떤 프로세스가 어떤 자원을 할당 받아 사용 중인지 확인 가능
- 어떤 프로세스가 어떤 자원을 기다리고 있는지 확인 가능

    ![image](https://github.com/boost-library/yong-study/assets/74396128/ff0654e3-fbc6-47ea-b360-562b2b86fa31)

    - 웹 브라우저 프로세스는 자원 B를 할당받았고, 자원 A의 사용을 기다리고 있고
    - 게임 프로세스는 자원 A를 할당받았고, 자원 B의 사용을 기다리고 있음


    **교착 상태가 일어난 그래프의 특징**


    - 자원 할당 그래프가 <Mark>원의 형태</Mark>를 띄고 있다

2. 교착 상태가 일어나는 근본적인 이유 이해하기

교착 상태가 발생할 조건

1. <Mark>상호 배제**mutual exclusion**
    
    한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
    
2. <Mark>점유와 대기**hold and wait**
    
    자원을 할당 받은 상태에서 다른 자원의 할당 받기를 기다리는 상태
    
3. <Mark>비선점**Nonpreemption**
    
    어떤 프로세스도 다은 프로세스의 자원을 강제로 빼앗지 못하는 상태
    
4. <Mark>환형 대기**circular wait**
    
    프로세스들이 원의 형태로 자원을 대기하는 상태
    

위 네 가지 조건 중 하나라도 만족하지 않으면 <Mark>교착상태가 발생하지 않음

위 네 가지 조건을 모두 만족하면 <Mark>교착 상태가 발생할 수 있음

## 교착 상태 해결 방법

교착 상태 해결

- 예방, 회피, 검출 후 회복

### 교착 상태 예방

### 

- 애초에 교착 상태가 발생하지 않도록 교착 상태 발생 조건(상호 배제, 점유와 대기, 비선점, 환형 대기) 중 하나를 없애버리기
    - 상호 배제를 없애면?
        - 모든 자원을 공유 → 이론적으론 가능, 현실적으론 ❌
    - 점유와 대기를 없애면?
        - 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분
            
            → 자원의 활용룰 낮출 수 있는 방식
            
    - 비선점 조건을 없애면?
        - 선점이 가능한 자원(e.g. CPU)에 한해 효과적
            
            → 모든 자원이 선점 가능한 것은 아니다
            
    - 환형 대기 조건을 없애면?
        - 자원에 <Mark>번호</Mark>를 붙이고 <Mark>오름차순</Mark>으로 할당하면 원형 대기는 발생하지 않음
            
            → 자원에 번호 붙이는 것은 어려운 작업, 어떤 자원에 어떤 번호를 붙이느냐에 따라 활용률이 달라진다
            
- 교착 상태가 발생하지 않음을 보장할 수 있으나 부작용이 따르는 방식

### 교착 상태 회피

- 교착 상태를 <Mark>무분별한 자원 할당으로 인해 발생</Mark>했다고 간주
- 교착 상태가 발생하지 않을 만큼 <Mark>적절하게 할당</Mark>하기
- 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 만큼만 자원 배분

1. 안전 순서열: 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
2. 안전 상태: 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태
    
    안전 순서열이 있는 상태
        ![image](https://github.com/boost-library/yong-study/assets/74396128/38e5374d-fa0d-4200-b79c-5339298da6ea)
    P2 → P1 → P3이라는 안전 순서열대로 할당하면 모든 프로세스 실행 가능

3. 불안전 상태: 교착 상태가 발생할 수도 있는 상태
    
    안전 순서열이 없는 상태
        ![image](https://github.com/boost-library/yong-study/assets/74396128/ec6d7c4f-d4cc-46f9-8675-45ebf2ffd283)

- 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당하는 방식
- 항시 안전 상태를 유지하도록 자원을 할당하는 방식
- c.f. 은행원 알고리즘

### 교착 상태 검출 후 회복

- 교착 상태의 발생을 인정하고 사후에 조치하는 방식
- 프로세스가 자원을 요구하면 일단 할당, 교착 상태가 검출되면 회복
- <Mark>선점을 통한 회복, 프로세스 강제 종료를 통한 회복
    - 선점을 통한 회복
        - 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
    - 프로세스 강제 종료를 통한 회복
        - 교착 상태에 놓인 프로세스 모두 강제 종료 → 작업 내용을 잃을 위험
        - 교착 상태가 해결될 떄까지 한 프로세스씩 강제 종료 → 오버헤드

### 교차상태 무시

**타조 알고리즘**

교착 상태가 발생할 수 있지만, 이를 무시하고 시스템을 계속 운영하는 방법. 이 방법은 교착 상태의 심각성이 낮거나 복구 비용이 더 큰 경우에 적용.
