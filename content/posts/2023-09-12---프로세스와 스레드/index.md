---
title: 프로세스와 스레드
date: "2023-09-12T20:35:32.169Z"
template: "post"
draft: false
slug: "/posts/os/process-thread"
category: "OS"
tags:
  - "OS"
  - "CS"  
description: "프로세스와 스레드에 대해서 배웁니다"
---

- [프로세스 상태와 계층구조](#프로세스-상태와-계층구조)
    - [프로세스 상태](#프로세스-상태)
    - [프로세스 계층 구조](#프로세스-계층-구조)
    - [프로세스 생성 기법](#프로세스-생성-기법)
    - [ROM-BIOS](#rom-bios)
- [스레드](#스레드)
    - [프로세스와 스레드](#프로세스와-스레드)
    - [멀티 프로세스와 멀티 스레드](#멀티-프로세스와-멀티-스레드)
- [프로세스 확인하기](#프로세스-확인하기)
- [스레드 확인하기](#스레드-확인하기)
- [CPU 스케줄링 개요](#cpu-스케줄링-개요)
    - [프로세스 우선순위](#프로세스-우선순위)
    - [스케줄링 큐](#스케줄링-큐)
- [선점형(Preemptive)과 비선점형 스케줄링(Non-preemptive)](#선점형과-비선점형-스케줄링)
- [CPU 스케줄링 알고리즘](#cpu-스케줄링-알고리즘)

## 프로세스 상태와 계층구조

### 프로세스 상태

- 생성상태
    - 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
    - 준비가 완료되었다면 준비 상태로
- 준비상태
    - 당장이라도 CPU를 할당 받아 실행할 수 있지만
    - 자신의 차례가 아니기에 기다리는 상태
    - 자신의 차례가 된다면 실행 상태로(=<Mark>디스패치</Mark>(준비→실행))
- 실행상태
    - CPU를 할당 받아 실행 중인 상태
    - 할당된 시간 모두 사용 시(<Mark>타이머 인터럽트</Mark>(할당된 시간을 전부 사용했음을 나타내는 하드웨어 인터럽트) 발생 시) 준비 상태로
    - 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지(<Mark>입출력 완료 인터럽트를 받을 때까지</Mark>) 대기 상태로
- 대기상태(block state)
    - 프로세스가 실행 도중 입출력장치를 사용하는 경우
    - 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
    - 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로
- 종료상태
    - 프로세스가 종료된 상태
    - PCB, 프로세스의 메모리 영역 정리
        ![image](https://github.com/boost-library/yong-study/assets/74396128/eccf0a31-0da9-4dbb-83c2-c9b5983bc9e0)

### 프로세스 계층 구조

- 프로세스 실행 도중(<Mark>시스템 호출을 통해</Mark>) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스: 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스: 자식 프로세스
    - 부모 프로세스와 자식 프로세스는 <Mark>별개의 프로세스</Mark>이므로 <Mark>각기 다른 PID</Mark>를 가짐
    - 일부 운영체제에서는 자식 프로세스 <Mark>PCB에 부모 프로세스 PID(PPID)를 명시하기도
    
    → 프로세스의 게층적인 구조 형성
    
- OS에서 데몬 프로세스는 백그라운드에서 실행되는 시스템 서비스나 작업을 수행하는 프로세스를 의미, 데몬 프로세스는 주로 리눅스와 유닉스 기반 운영 체제에서 많이 사용되며, Windows 운영 체제에서는 "서비스"
    - 데몬 프로세스는 처음으로 시작되는 프로세스의 자식 프로세스
        
        ```c
        최초의 프로세스 확인
        pstree
        ```
        
- c.f.) Windows는 계층 구조 ❌

### 프로세스 생성 기법

부모 프로세스는 <Mark>fork 시스템 호출</Mark>을 통해 자신의 복사본을 자식 프로세스로 생성

- 복사본(=자식 프로세스) 생성
- 부모 프로세스의 자원 상속

자식 프로세스는 <Mark>exec 시스템 호출</Mark>을 통해 <Mark>자신의 메모리 공간을 다른 프로그램으로 교체

- 메모리 공간을 새로운 프로그램으로 덮어쓰기
- 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화
    - <Mark>이때 부모 프로세스가 갖고있는 프로그램 내용은 자식 프로세스와 다르다.(별개)

### rom bios

ROM-BIOS(Read-Only Memory - Basic Input/Output System)은 운영 체제나 프로세스와 직접적으로 관련된 프로세스가 아니다. ROM-BIOS는 컴퓨터의 부팅 및 기본 입출력 시스템을 관리하는 하드웨어와 소프트웨어의 조합

ROM-BIOS는 컴퓨터의 기본 입력 및 출력 작업을 처리하며, 부팅 시 초기 하드웨어 설정 및 컴퓨터의 기본 동작을 관리. 이는 운영 체제의 부팅 전 단계에서 실행되며, 컴퓨터의 기본 하드웨어를 초기화하고 저장 장치에서 운영 체제를 로드. 이후 운영 체제가 로드되면 운영 체제가 컴퓨터 시스템을 제어하고 프로세스를 관리한다.

따라서 ROM-BIOS는 운영 체제나 프로세스와는 <Mark>구분되는 역할</Mark>을 한다. ROM-BIOS는 컴퓨터의 하드웨어와 초기 부팅 프로세스를 다루는데 사용되며, 운영 체제와 어플리케이션은 이후에 실행되는 소프트웨어.

## 스레드

스레드(thread)는 프로세스를 구성하는 실행 흐름의 단위

하나의 프로세스는 하나 이상의 스레드를 가질 수 있다
    ![image](https://github.com/boost-library/yong-study/assets/74396128/3c4fb422-9e0c-496e-972e-2e78e2e8897b)
    한 프로세스를 여러개의 스레드로 동시에 실행

### 프로세스와 스레드

실행 흐름이 하나인 프로세스(단일 스레드 프로세스)

실행 흐름이 여러 개인 프로세스(멀티 스레드 프로세스)

- 프로세스를 이루는 여러 명령어 동시 실행 가능

**스레드의 구성 요소**

스레드 ID, 프로그램 카운터를 비롯한 레지스터값, 스택 등

<Mark>실행에 필요한 최소한의 정보
    ![image](https://github.com/boost-library/yong-study/assets/74396128/d3363057-79d0-4a5d-a4a3-dcc086240e2f)
    🔥<Mark>프로세스를 이루는 모든 스레드들은 그 프로세스의 자원을 공유할 수 있다

- <Mark>리눅스</Mark> 운영체제에서의 스레드
    - <Mark>프로세스와 스레드는 “실행의 문맥(context of execution)”, 별개의 것으로 구분할 필요 ❌ - 리눅스 토발즈
    - <Mark>task</Mark>라는 용어로 대체하여 사용
    - 다른 운영체제에서는 아직까지 구분한다.
- c.f. ) 전통적인 관점의 전공서에서는 CPU한테 처리해야할 작업을 처리할 때 <Mark>프로세스 단위</Mark>로 전달한다고 나와있지만, 실제로 확인해보면 CPU한테 처리해야 할 작업을 전달하거나 CPU를 할당받아 실행되는 단위는 프로세스가 아니라 <Mark>스레드 단위</Mark>인 경우가 많다

### 멀티 프로세스와 멀티 스레드

동일한 작업을 수행하는 <Mark>단일 스레드 프로세스 여러 개</Mark> 실행 vs 하나의 프로세스를 <Mark>여러 스레드</Mark>로 실행
    ![image](https://github.com/boost-library/yong-study/assets/74396128/6d5006ba-9a51-4c5c-9017-6607c1a8498e)
    → 프로세스끼리는 기본적으로 자원을 공유하지 않지만 스레드끼리는 같은 프로세스의 자원을 공유하는 차이점이 있다

- process
    - 프로세스를 fork하면 코드/데이터/힙 영역 등 모든 자원이 복제되어 저장됨
    - 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재
        - c.f. ) 실제로는 fork 직후 같은 프로세스를 <Mark>통째로 메모리에 중복 저장하지 않으면서</Mark> 동시에 프로세스끼리 자원을 공유하지 않는 방법이 있다. 이를 <Mark>쓰기 시 복사(copy on write)기법</Mark>이라 한다.
- thread
    - 스레드들은 각기 다른 스레드 ID, (별도의 실행을 위해 꼭 필요한) 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유
        ![image](https://github.com/boost-library/yong-study/assets/74396128/52f79880-1bda-4bac-abd2-e0e0c012361d)
- 프로세스끼리는 자원을 공유하지 않는다 → 남남처럼 독립적으로 실행
    - 프로세스 간에도 자원을 주고받을 수 있다 → 프로세스 간 통신(IPC)
    - 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신
    - c.f.) socket, pipe …
- 스레드는 프로세스의 자원을 공유 → 비교적 멀티프로세스에 비해 협력과 통신에 유리
    - 스레드 하나에 문제가 생기면 전체 프로세스에 문제가 생길 수 있음    

## 프로세스 확인하기

```c
vi test.py
print("hello, os")
python3 test.py

// PID 확인
vi test.py

import os
os.getpid() // PID 22662

// -----------------------------------
from multiprocessing import Process
import os

def foo():
    print('foo: child process: ', os.getpid()) // 자식 PID
    print('foo: paraent process: ', os.getppid()) // 자식의 부모 PID(22784)

if __name__ == '__main__':
    print('paraent process: ', os.getpid()) // paraent process:  22784
    child = Process(target=foo).start() // 자식 프로세스 생성
// ------------------------------------

// 멀티 process 생성
from multiprocessing import Process
import os

def foo():
    print('foo: child process: ', os.getpid())
    print('foo: paraent process: ', os.getppid())

if __name__ == '__main__':
    print('paraent process: ', os.getpid())
    child1 = Process(target=foo).start()
    child2 = Process(target=foo).start()
    child3 = Process(target=foo).start()
```

## 스레드 확인하기

```c
vi test.py
----------
import threading
import os

def foo():
    print('foo: thread id is: ', threading.get_native_id())
    print('foo: my pid is: ', os.getpid()) 
		// 23222, thread는 process의 자원 공유

if __name__ == '__main__':
    print('PID: ', os.getpid()) // 23222
    thread1 = threading.Thread(target=foo).start()
----------

```

## cpu 스케줄링 개요

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

### 프로세스 우선순위

<Mark>입출력 작업</Mark>이 많은 프로세스(=<Mark>I/O Bound Process</Mark>, 입출력 집중 프로세스)의 우선순위는

<Mark>CPU 작업</Mark>이 많은 프로세스(=<Mark>CPU Bound Process</Mark>, CPU 집중 프로세스)의 우선순위 보다 높다

- I/O Bound Process는 대기 상태에서 더 많이 존재하기에 입출력 작업이 우선순위가 높아서 프로세스 먼저 실행

### 스케줄링 큐

- 반드시 FIFO일 필요는 ❌

특정 자원(cpu,hdd, i/o devcie)을 이용하고 싶어하는 프로세스들을 큐에 삽입해서 자원을 이용하도록 만듦

- 준비 큐와 대기 큐
    - 준비 큐: CPU를 이용하기 위해 기다리는 줄
    - 대기 큐: 입출력장치를 이용하기 위해 기다리는 줄
        - 같은 장치를 요구한 프로세스들은 같은 큐에서 대기
            ![image](https://github.com/boost-library/yong-study/assets/74396128/dca033ec-bdaf-4241-a16c-d5189c97c5a9)
        - 먼저 큐에 삽입되더라도 반드시 먼저 실행되는 것은 아님, 우선순위가 높은 프로세스가 CPU를 이용 

## 선점형과 비선점형 스케줄링

**선점형 스케줄링(Preemptive)**

- 현재 CPU를 사용중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당
- 어떤 프로세스 하나가 CPU 자원 하나를 독점해서 쓸 수 없는 스케줄링 방식
- 프로세스마다 정해진 시간만큼 CPU를 쓰게 하고 정해진 시간을 모두써서 타임아웃 인터럽트가 발생하면 OS가 다음 프로세스에게 CPU자원을 넘겨줌
- 장점
    - 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분 가능
- 단점
    - 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다

**비선점형 스케줄링((Non-preemptive))**

- 현재 CPU를 사용중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기
- 어느 한 프로세스가 자원을 이용하고 있다면 종료되거나 대기상태에 접어들기 전까지 다른 끼어들 수 ❌
- 장점
    - 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다
- 단점
    - 모든 프로세스가 골고루 자원을 이용하기 어렵다

c.f. ) 문맥교환
    다중 프로그래밍 및 다중 작업 환경에서 발생하는 프로세스 간의 전환 작업을 의미

문맥 교환은 현재 실행 중인 프로세스의 상태(문맥)를 저장하고, 다음으로 실행될 프로세스의 상태를 복원하는 과정을 포함. 이를 통해 여러 프로세스가 CPU를 공유하며 실행될 수 있습니다.

문맥 교환은 다음과 같은 상황에서 발생할 수 있음:

1. 인터럽트: 하드웨어 인터럽트(예: 타이머 인터럽트, 입출력 완료 인터럽트) 또는 소프트웨어 인터럽트(예: 시스템 호출)에 의해 발생.
2. 스케줄러 결정: <Mark>스케줄러는 실행 중인 프로세스 중 하나를 중단하고 다른 프로세스를 실행하도록 결정할 때 발생</Mark>합니다. 이를 통해 다양한 프로세스 간에 CPU 시간을 공정하게 분배할 수 있음.
3. 입출력 작업: 입출력 작업을 수행하는 동안 CPU가 대기 상태에 들어가는 경우, 다른 프로세스로 전환하여 시스템 자원을 최대한 활용합니다.

문맥 교환은 오버헤드를 발생시킬 수 있으므로, 효율적으로 수행하기 위해 하드웨어와 운영 체제가 최적화되어야 한다. 문맥 교환은 다중 프로그래밍 환경에서 여러 작업이 동시에 실행될 수 있도록 해주는 핵심적인 운영 체제 기능 중 하나

## cpu 스케줄링 알고리즘

1. 선입 선처리 스케줄링
    
    **FCFS(First Come First Served) 스케줄링**
    
    - 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
    - 먼저 CPU를 요청한 프로세스부터 CPU 할당
    - 단점: 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용(=호위 효과)
        ![image](https://github.com/boost-library/yong-study/assets/74396128/1c69dc56-e150-4184-a615-8404e80b1fd6)
2. 최단 작업 우선 스케줄링
    
    **SJF(Shortest Job First) 스케줄링**
    
    - 호위 효과를 방지하려면
    - CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
        ![image](https://github.com/boost-library/yong-study/assets/74396128/d7e0510c-a903-43d5-b125-457e10ec52fc)
    - CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식
        - 선점형 → 최소 잔여 시간 우선 스케줄링
        - 비선점형 → 주로


3. 라운드 로빈 스케줄링
    
    **RR(Round Robin) 스케줄링**
    
    - 선입 선처리 스케줄링 + <Mark>타임 슬라이스(time slice)
    - 타임 슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
        - 타임 슬라이스의 크기가 중요, 너무 커지면 FCFS와 유사해져서 호위 효과가 생길 수도
        - 너무 작으면 문맥교환이 발생하는 오버헤드 떄문에 CPU 부담이 너무 커짐
    - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
        - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
        - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입(문맥교환)
            ![image](https://github.com/boost-library/yong-study/assets/74396128/0a55b185-8bb3-4fef-9548-2c8a3a577545)

4. 최소 잔여 시간 우선 스케줄링
    
    **SRT(Shortest Remaining Time) 스케줄링**
    
    - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
    - 최단 작업 우선 스케줄링: 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
    - 라운드 로빈 스케줄링: 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
    - 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 <Mark>남은 작업 시간이 가장 적은 프로세스 선택
5. 우선순위 스케줄링
    - 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
    - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
    - 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 C 우선 순위 스케줄링
        - 최단작업우선스케줄링: 작업시간이 짧은 프로세스한테 높은 우선수위를 부여하는 방식
        - 최소잔여시간스케줄링: 남아있는 시간이 짧은 프로세스한테 높은 우선순위를 부여하는 방식
    - 우선순위 스케줄링의 근본적인 문제점, <Mark>기아(starvation)현상
    - 우선순위 높은 프로세스만 주구장창 실행
    - 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
    - 기아현상을 방지하기 위한 기법: <Mark>에이징(aging)
    - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
    - 대기 중인 프로세스의 우선순위를 점차 증가시키는 방법
        - 우선순위가 낮아도 언젠가는 우선순위가 높아진다
6. 다단계 큐 스케줄링
    
    **Multilevel queue 스케줄링**
    
    - 우선순위 스케줄링의 발전된 형태
    - 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식
        - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
        - 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리
            ![image](https://github.com/boost-library/yong-study/assets/74396128/dd6f2ca2-8b02-4995-81b3-62b5907b9989)
        - 큐 간의 이동이 불가, 우선순위가 낮은 프로세스는 우선순위가 낮은 큐에서 높은 큐로 이동 불가능하므로 <Mark>기아현상</Mark> 발생 가능

7. 다단계 피드백 큐 스케줄링
    
    **Multilevel feedback queue 스케줄링**
    
    - 다단계 큐 스케줄링의 발전된 형태
    - 큐 간의 이동이 가능한 다단계 큐 스케줄링
    - 다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동 불가
        - 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
        - 기아 현상 발생 가능
            ![image](https://github.com/boost-library/yong-study/assets/74396128/d36488cf-0cbc-4c6c-92df-d25d060ca790)
    - 준비상태의 프로세스를 가장 높은 우선순위 큐에 삽입, 차례가 오면 CPU할당 받고 실행, 실행이 안끝났으면 다음 실행 우선순위 큐로 이동해서 실행.. 스케줄링의 반복. 타임 슬라이스 동안 실행을 다 못 끝내면 낮은 우선순위로 이동
        - 자연스럽게 CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고
            - 다단계 피드백 큐에서도 에이징 기법 적용 가능 →  기아현상 해결 가능
        - 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐

즉, 어떤 프로세스의 CPU 시간이 길면 우선순위가 낮아지고 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식

일반적인 CPU 스케줄링 방식으로 알려져 있음