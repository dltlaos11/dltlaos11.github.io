---
title: 0과1로 문자,숫자를 표현하는 방법
date: "2023-08-24T20:40:32.169Z"
template: "post"
draft: false
slug: "/posts/computer-architecture/expression-letters-and-numbers-with-0&1"
category: "Computer Architecture"
tags:
  - "ComputerArchitecture"
  - "CS"
description: "컴퓨터 구조의 0과1로 문자,숫자를 표현하는 방법에 대해서 배웁니다."
---

- [0과 1로 숫자를 표현하는 방법](#0과-1로-숫자를-표현하는-방법)
  - [정보 단위](#정보-단위)
  - [이진법: 0과 1로 숫자 표현하기](#이진법)
  - [십육진법](#십육진법)
  - [십육진법과 이진법의 관계](#십육진법과-이진법의-관계)
- [0과 1로 문자를 표현하는 방법](#0과-1로-문자를-표현하는-방법)
  - [문자 집합과 인코딩](#문자-집합과-인코딩)
  - [유니코드 문자 집합과 utf-8](#유니코드-문자-집합과-utf-8)

## 0과 1로 숫자를 표현하는 방법

#### 정보 단위

비트(bit): 0과 1을 표현하는 가장 작은 정보 단위

- n비트로 2^n가지의 정보 표현 가능
- 프로그램은 수 많은 비트로 이루어져 있음
- 비트보다 더 큰 단위를 주로 사용

  - 바이트, 킬로바이트, 메가바이트, 기가바이트. 테라바이트 …
    ![image](https://github.com/boost-library/yong-study/assets/74396128/d95e95af-ae06-45ed-9a78-eff7181c92d0)
    c.f.) 이전 단위를 1024개씩 묶은 단위는 kiB, MiB, GiB, …

    최근에는 정보 단위가 커지면서 1000개씩 묶은 단위와 1024개씩 묶은 단위를 구분해서 사용

##### 워드(word)

- CPU가 한 번에 처리할 수 있는 정보의 크기 단위(ex_CPU가 한번에 32bit처리 → 1word = 32bit)
- 하프 워드(half word): 워드의 절반 크기
- 풀 워드(full word): 워드 크기
- 더블 워드(double word): 워드의 두 배 크기

#### 이진법

1. 이진법(binary)

- 0과 1로 수를 표현하는 방법
- 숫자가 1을 넘어가는 시점에 자리올림
- 우리가 일상적으로 사용하는 진법은 숫자가 9를 넘어갈 떄 자리올림하는 십진법

2. 이진수 8 표기

- 1000 <mark>(2)
- <Mark>0b</Mark>1000

3. 0과 1로 음수 표현하기: 2의 보수(현대 컴퓨터에서 가장 많이 사용되는 방법)

- 어떤 수를 그보다 큰 2^n에서 뺸 값 - 11(2)을 음수로 표현한 값 구하는 <Mark>어려운</Mark> 방법
- 11(2)보다 큰 2^n = 100(2) - 100(2)
- 11(2) = 01(2) - 11(2)을 음수로 표현한 값 구하는 <Mark>쉬운</Mark> 방법
- 모든 0과 1을 뒤집고 1 더한 값 - 11(2) → 01(2)

  > “ -1011(2)를 표현하기 위한 0101(2)과 십진수 5를 표현하기 위한 0101(2)은 유사 같다. 어떻게 구분해야 할까?”

  > → CPU 내부에 <Mark>플러그(flug)</Mark> 레지스터로 구분

#### 십육진법

1. 십육진법(hexadecimal)

- 이진법으로는 숫자가 너무 길어지는 단점이 존재
- 컴퓨터의 데이터를 표현할 떄 16진법도 많이 사용
  - 15를 넘어가는 시점에 자리올림

2. 십육진수 15표기

- 15(16) - 수학적 표기 방식
- 0x15 - 코드상 표기 방식
  <img width="677" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/bd16e350-dfe2-4098-84bd-a0c07aa90f82">

#### 십육진법과 이진법의 관계

16진수와 2진수간 변환이 쉬우므로 많이 사용된다.

2진수 → 16진수
<img width="677" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/c1c4260f-90d5-40d6-b181-93b2a1a21b9d">
16진수 → 2진수
![image](https://github.com/boost-library/yong-study/assets/74396128/1326355a-985c-4181-b03e-bbb5817d388a)

## 0과 1로 문자를 표현하는 방법

#### 문자 집합과 인코딩

1. 인코딩(encoding)

- 코드화하는 과정
- 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정

2. 디코딩(decoding)

- 코드를 해석하는 과정
- 0과 1로 표현된 문자 코드로 문자로 변환하는 과정

3. 문자 집합(character set)

- 컴퓨터가 이해할 수 있는 문자의 모음
- 아스키 코드
  - 초창기 문자 집합 중 하나
  - 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
  - 7비트로 하나의 문자 표현(2^7= 128개의 문자 표현)
    - 8비트 중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)
    - A는 65로 인코딩, a는 97로 인코딩
    - c.f.) 65, 97 → 코드 포인트(code point)라고 하기도 == 문자에 부여된 값
  - 간단한 인코딩
  - But 한글을 포함한 다른 언어 문자, 다양한 특수 문자 표현 불가
    - 아스키 코드는 7비트로 하나의 문자를 표현하기에 128개보다 많은 문자를 표현할 수 없음
    - 8비트 확장 아스키(expected ASCII)의 등장, 여전히 부족
      ⇒ <Mark>언어별 인코딩 방식의 등장</Mark>

4. 한글 인코딩: 완성형 vs 조합형 인코딩

- 한글을 위한 인코딩이 필요
  - 알파벳을 이어 쓰면 단어가 되는 영어
  - 초성, 중성, 종성의 조합으로 이루어진 한글
  - 완성형 인코딩 방식과 조합형 인코딩 방식이 존재
    <img width="648" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/925b4227-9e47-4039-9bab-880daccc8aa3">
- EUC-KR
  - KS X 1001 KS X 1003 문자집합 기반의 한글 인코딩 방식
  - 완성형 인코딩
  - 글자 하나 하나에 2바이트 크기의 코드 부여 - 2바이트 == 16비트 == 4자리 16진수로 표현
    <img width="619" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/699029a1-2580-4a9e-ac0d-dfddd1ad634b">
  - 2300여개의 한글 표현 가능
  - 여전히 모든 한글을 표현하기에는 부족한 수
  - 쀏, 뙠, 훽같은 한글은 표현 불가능

다국어를 지원하는 프로그램을 개발하는 경우 언어별 인코딩 방식을 모두 이해해야하는 번거로움

→ <Mark>유니코드 문자 집합과 utf-8의 등장

#### 유니코드 문자 집합과 utf-8

1. 유니코드

- 통일된 문자 집합
- 한글, 영어, 화살표와 같은 특수 문자, 심지어 이모티콘까지
- 현대 문자 표현에 있어 매우 중요한 위치

2. 유니코드의 인코딩 방식

- utf-8, utf-16, utf-32
  <img width="261" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/6e98311c-aba3-4bca-afbc-2dd25c587a93">
  고유한 16진수 값: U+219B(=유니코드 코드 포인트)

  코드 포인트 그대로 문자 인코딩 값으로 삼지 않고 다양한 인코딩 방식으로(utf-8, 16, …) 0과 1로 만든다.

3. utf-8 인코딩

- UTF(Unicode Transformation Format) == 유니코드 인코딩 방법
- 가변 길이 인코딩: 인코딩 결과가 1바이트~4바이트
- 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값(<Mark>유니코드 코드 포인트</Mark>)에 따라 다름
  <img width="705" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/3d746a61-4e43-4b3f-b7d7-963007aa7479">
  <img width="702" alt="image" src="https://github.com/boost-library/yong-study/assets/74396128/125a4af8-837d-45cd-a3f0-e512f7c46441">

⇒ utf-8은 유니코드 문자를 인코딩하는 방법, utf-8로 인코딩한 값은 <Mark>가변길이 인코딩</Mark>이기 떄문에 1바이트~4바이트가 될 수 있다. 어떤 식으로 인코딩이 진행되는지는 <Mark>유니코드 문자에 부여된 코드 포인트의 범위</Mark>에 따라서 코드 포인트를 형식에 맞게 넣어주면 인코딩 된 결과.
