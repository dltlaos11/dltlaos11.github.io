{"componentChunkName":"component---src-templates-post-template-post-template-tsx","path":"/posts/명령어의 구조와 주소 지정 방식","result":{"data":{"markdownRemark":{"id":"22254616-0c62-5720-a37c-116f88dc2328","html":"<ul>\n<li><a href=\"#%EC%97%B0%EC%82%B0-%EC%BD%94%EB%93%9C\">연산 코드</a></li>\n<li><a href=\"#%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C\">오퍼랜드</a>\n<ul>\n<li><a href=\"#%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%B0%A9%EC%8B%9D\">명령어 주소 지정 방식</a></li>\n</ul>\n</li>\n</ul>\n<img width=\"655\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/97930271-9ee6-4c31-a3b8-678ce9a78ade\">\n<p>명령어는 연산 코드와 오퍼랜드로 구성된다.</p>\n<h2 id=\"연산-코드\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%82%B0-%EC%BD%94%EB%93%9C\" aria-label=\"연산 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연산 코드</h2>\n<ol>\n<li>\n<p>연산 코드: 수행할 연산</p>\n<p>대표적인 연산 코드의 종류</p>\n<ol>\n<li>데이터 전송\nCPU마다 연산코드의 종류가 다르므로 유형을 파악\n<ul>\n<li>MOVE: 데이터 옮겨라(레지스터에서 다른 레지스터의 데이터 이동)</li>\n<li>STORE: 메모리에 저장</li>\n<li>LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라</li>\n<li>PUSH: 스택에 데이터를 저장하라</li>\n<li>POP: 스택의 최상단 데이터를 가져와라</li>\n</ul>\n</li>\n<li>산술/논리 연산\n<img width=\"630\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/8ed6ff54-8c07-4522-b337-171ad8358c75\"></li>\n<li>제어 흐름 변경\n<img width=\"626\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/a6f47f37-faa7-4364-a373-c067a3e5e9b9\"></li>\n<li>입출력 제어\n<img width=\"629\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/37450662-4e37-4e11-bd4f-67a253bb066a\"></li>\n</ol>\n<p>c.f.) 연산 코드의 종류 &#x26; 생김새는 <Mark>CPU</Mark> 마다 다르다.</p>\n</li>\n</ol>\n<h2 id=\"오퍼랜드\" style=\"position:relative;\"><a href=\"#%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C\" aria-label=\"오퍼랜드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>오퍼랜드</h2>\n<p>오퍼랜드: 연산에 사용될 데이터 혹은 <Mark>연산에 사용될 데이터가 저장된 위치</Mark>(주로 저장되는 정보), 오퍼랜드 필드를 <Mark>주소 필드(메모리 주소, 레지스터)</Mark>라고 하기도 한다.</p>\n<p>어셈블리어나 기계어는 저급언어들은 <Mark>명령어</Mark>로 이루어져 있다.</p>\n<img width=\"656\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/9777e2f1-87ed-4dff-9d51-aa5a1a43bf6c\">\n<img width=\"654\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/c52148c4-bb51-4f96-b5b6-6e86652de234\">\n<p>붉은색 글자가 연산코드이고, 우측에 있는 글자가 오퍼랜드이다. 오퍼랜드가 없는 경우, 1개 이상인 경우도 존재</p>\n<h4 id=\"명령어-주소-지정-방식\" style=\"position:relative;\"><a href=\"#%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%A3%BC%EC%86%8C-%EC%A7%80%EC%A0%95-%EB%B0%A9%EC%8B%9D\" aria-label=\"명령어 주소 지정 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>명령어 주소 지정 방식</h4>\n<h5 id=\"왜-굳이-오퍼랜드에-저장된-위치를-사용할까\" style=\"position:relative;\"><a href=\"#%EC%99%9C-%EA%B5%B3%EC%9D%B4-%EC%98%A4%ED%8D%BC%EB%9E%9C%EB%93%9C%EC%97%90-%EC%A0%80%EC%9E%A5%EB%90%9C-%EC%9C%84%EC%B9%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C\" aria-label=\"왜 굳이 오퍼랜드에 저장된 위치를 사용할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 굳이 오퍼랜드에 저장된 위치를 사용할까?</h5>\n<p>=> 명령어 내에서 표현할 수 있는 데이터의 크기가 제한되기 때문\n<img width=\"657\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/96d41a2c-ea11-4de1-b76a-01fb548863b3\">\n<img width=\"657\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/96439245-45ab-4236-a676-ce62d4af6513\"></p>\n<ol>\n<li>유효 주소(effective address)</li>\n</ol>\n<ul>\n<li>연산에 사용할 데이터가 저장된 위치</li>\n</ul>\n<ol start=\"2\">\n<li>명령어 주소 지정 방식(addressing modes)</li>\n</ol>\n<ul>\n<li>연산에 사용할 데이터가 저장된 위치를 찾는 방법</li>\n<li>유효 주소를 찾는 방법</li>\n<li>다양한 명령어 주소 지정 방식들 존재\n<ul>\n<li>즉지 주소 지정 방식(immediate addressing mode)\n<ul>\n<li>연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시</li>\n<li>가장 간단한 형태의 주소 지정 방식</li>\n<li>연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름\n<img width=\"599\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/a5770823-f552-4040-9e56-d615eb2fb5b6\"></li>\n</ul>\n</li>\n<li>직접 주소 지정 방식(direct addressing mode)\n<ul>\n<li>오퍼랜드 필드에 유효 주소 직접적으로 명시</li>\n<li>유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦\n<img width=\"601\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/0e023bcd-a385-483a-bc9f-3b37c74bb605\"></li>\n</ul>\n</li>\n<li>간접 주소 지정 방식(indirect addressing mode)\n<ul>\n<li>오퍼랜드 필드에 유효 주소의 주소를 명시</li>\n<li>앞선 주소 지정 방식들에 비해 속도가 느림\n<img width=\"602\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/64f0631e-b2e0-4574-8dd0-7a38fd7635ed\">\n<Mark>c.f.) CPU가 메모리를 찾아가는 과정은 속도가 느리다, 메모리 접근을 최소화 해야함.</li>\n</ul>\n</li>\n<li>레지스터 주소 지정 방식(register addressing mode)\n<ul>\n<li>연산에 사용할 데이터가 저장된 레지스터 명시</li>\n<li><Mark>CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름🔥 - 레지스터는 CPU안에 존재\n<img width=\"601\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/61bb3663-00a5-439d-b020-150dda7629ce\"></li>\n</ul>\n</li>\n<li>레지스터 간접 주소 지정 방식(register indirect addressing mode)\n<ul>\n<li>연산에 사용할 데이터를 메모리에 저장</li>\n<li>그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시\n<img width=\"597\" alt=\"image\" src=\"https://github.com/boost-library/yong-study/assets/74396128/12bdfefa-dfbb-403f-a610-c494d1e1f434\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/posts/2023-08-24---명령어의 구조와 주소 지정 방식//posts/명령어의 구조와 주소 지정 방식","tagSlugs":["/tag/cs/"]},"frontmatter":{"date":"2023-08-24T23:40:32.169Z","description":"컴퓨터 구조의 명령어의 구조와 주소 지정 방식에 대해서 배웁니다.","tags":["CS"],"title":"명령어의 구조와 주소 지정 방식","socialImage":null}}},"pageContext":{"slug":"/posts/2023-08-24---명령어의 구조와 주소 지정 방식//posts/명령어의 구조와 주소 지정 방식"}},"staticQueryHashes":["2236276093","251939775","401334301"]}